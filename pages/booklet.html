<!DOCTYPE html>
<html lang="fa" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Bootcamp</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="shortcut icon" href="../assets/img/Git_icon.svg.png" type="image/x-icon">
</head>

<body>
<main>
    <aside class="sidebar active" data-sidebar>
        <div class="sidebar-info">
            <figure class="avatar-box" style="padding: 10px;">
                <img class="avara-img" src="../assets/img/Git_icon.svg.png">
            </figure>

            <div class="info-content">
                <h1 class="name" title="Richard Hanrick">بوت‌کمپ گیت</h1>
                <p class="title">1404 - 1405</p>
            </div>

            <div class="my-body">
                <div id="theme-toggle" class="darkThemeBtn">
                    <input id="darkmode-toggle" type="checkbox">
                    <label for="darkmode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"
                             class="size-5 sun">
                            <path
                                    d="M10 2a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 10 2ZM10 15a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 10 15ZM10 7a3 3 0 1 0 0 6 3 3 0 0 0 0-6ZM15.657 5.404a.75.75 0 1 0-1.06-1.06l-1.061 1.06a.75.75 0 0 0 1.06 1.06l1.06-1.06ZM6.464 14.596a.75.75 0 1 0-1.06-1.06l-1.06 1.06a.75.75 0 0 0 1.06 1.06l1.06-1.06ZM18 10a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1 0-1.5h1.5A.75.75 0 0 1 18 10ZM5 10a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1 0-1.5h1.5A.75.75 0 0 1 5 10ZM14.596 15.657a.75.75 0 0 0 1.06-1.06l-1.06-1.061a.75.75 0 1 0-1.06 1.06l1.06 1.06ZM5.404 6.464a.75.75 0 0 0 1.06-1.06l-1.06-1.06a.75.75 0 1 0-1.061 1.06l1.06 1.06Z"/>
                        </svg>


                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"
                             class="size-5 moon">
                            <path fill-rule="evenodd"
                                  d="M7.455 2.004a.75.75 0 0 1 .26.77 7 7 0 0 0 9.958 7.967.75.75 0 0 1 1.067.853A8.5 8.5 0 1 1 6.647 1.921a.75.75 0 0 1 .808.083Z"
                                  clip-rule="evenodd"/>
                        </svg>

                    </label>
                    <span class="fake-body"></span>
                </div>

                <button class="info-more-btn" data-sidebar-btn style="margin-top: 12px;">
                    <svg id="info-more-btn" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                         fill="currentColor" class="size-5" style="width: 20px; height:20px;">
                        <path fill-rule="evenodd"
                              d="M10 3a.75.75 0 0 1 .75.75v10.638l3.96-4.158a.75.75 0 1 1 1.08 1.04l-5.25 5.5a.75.75 0 0 1-1.08 0l-5.25-5.5a.75.75 0 1 1 1.08-1.04l3.96 4.158V3.75A.75.75 0 0 1 10 3Z"
                              clip-rule="evenodd"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="sidebar-info-more">
            <div class="separator"></div>

            <ul class="contacts-list">
                <li class="contact-item">
                    <div class="icon-box">
                        <ion-icon name="git-compare-outline"></ion-icon>
                    </div>

                    <div class="contact-info">
                        <p class="contact-title">برگزار کننده</p>

                        <span class="contact-link">انجمن علمی مهندسی کامپیوتر</span>
                    </div>
                </li>

                <li class="contact-item">
                    <div class="icon-box">
                        <ion-icon name="person-outline"></ion-icon>
                    </div>

                    <div class="contact-info">
                        <p class="contact-title">مدرس</p>

                        <span class="contact-link">امیر توانا</span>
                    </div>
                </li>
            </ul>

            <div class="separator"></div>

            <ul class="social-list">
                <li class="social-item"><a href="https://www.github.com/amirtvn04/" class="social-link" target="_blank">
                    <ion-icon name="logo-github"></ion-icon>
                </a></li>
                <li class="social-item"><a href="https://www.instagram.com/amirtvn04/" class="social-link"
                                           target="_blank">
                    <ion-icon name="logo-instagram"></ion-icon>
                </a></li>
                <li class="social-item"><a href="https://t.me/amirtvn04" class="social-link" target="_blank">
                    <ion-icon name="paper-plane"></ion-icon>
                </a></li>
            </ul>
        </div>
    </aside>

    <div class="custom-sidebar">
        <div id="scroll-container">
            <div id="indicator"></div>
        </div>
    </div>

    <div class="main-content">
        <nav class="navbar">
            <ul class="navbar-list">
                <li class="navbar-item">
                    <button class="navbar-link active" data-nav-link>فصل ۰</button>
                </li>
                <li class="navbar-item">
                    <button class="navbar-link" data-nav-link>فصل ۱</button>
                </li>
                <li class="navbar-item">
                    <button class="navbar-link" data-nav-link>فصل ۲</button>
                </li>
<!--                <li class="navbar-item">-->
<!--                    <button class="navbar-link" data-nav-link>فصل ۳</button>-->
<!--                </li>-->
<!--                <li class="navbar-item">-->
<!--                    <button class="navbar-link" data-nav-link>فصل ۴</button>-->
<!--                </li>-->
            </ul>
        </nav>

        <article class="about active" data-page="فصل ۰">
            <h2 class="h2">فصل ۰ - شروع به کار</h2>
            <ul class="article-list code-example" style="margin-bottom: 24px">
                <li><span>فهرست مطالب فصل</span></li>
                <li><a href="#titr-1">۰.۱ - آشنایی با سیستم کنترل نسخه</a></li>
                <li><a href="#titr-2">۰.۲ - Git چیست؟</a></li>
                <li><a href="#titr-3">۰.۳ - نصب Git روی سیستم‌عامل‌های مختلف</a></li>
                <li><a href="#titr-4">۰.۴ – ستاپ اولیه Git</a></li>
                <li><a href="#titr-5">۰.۵ – جمع‌بندی فصل</a></li>
            </ul>

            <header>
                <h2 id="titr-1" class="h2 article-title">۰.۱ - آشنایی با سیستم کنترل نسخه</h2>
            </header>

            <section class="about-text">
                <p>در مسیر توسعه‌ی نرم‌افزار، تغییرات <span class="text_bold">پیوسته و همیشگی</span> هستند.
                    برنامه‌نویسان هر روز کد می‌نویسند، اصلاح
                    می‌کنند، ویژگی‌های جدید اضافه می‌کنند و گاهی لازم است تغییرات انجام‌شده را بررسی کنند یا به نسخه‌ی
                    قبلی بازگردند. در پروژه‌های تیمی این موضوع حساس‌تر می‌شود؛ زیرا چندین توسعه‌دهنده ممکن است همزمان
                    روی بخش‌های مختلف پروژه کار کنند و طبیعی است که گاهی تغییرات با یکدیگر <span
                            class="text_bold">تداخل</span> داشته باشند. تصور کنید
                    یکی از اعضای تیم بخشی از کد را تغییر داده و فرد دیگری همان قسمت را با نسخه‌ی متفاوت ویرایش کرده
                    باشد. اگر مکانیزمی برای مدیریت این تغییرات وجود نداشته باشد، پروژه می‌تواند به سرعت دچار آشفتگی شود.
                </p>
                <p>
                    اینجاست که مفهوم <span class="text_bold">Version Control</span> یا سیستم کنترل نسخه ظاهر می‌شود.
                    Version Control ابزاری است که
                    تغییرات فایل‌ها را در <span class="text_bold">گذر زمان ثبت و ذخیره می‌کند</span>. این سیستم به
                    توسعه‌دهندگان اجازه می‌دهد نسخه‌های
                    مختلف پروژه را مشاهده کنند، تغییرات را با جزئیات بررسی نمایند، به نسخه‌های قدیمی‌تر بازگردند و مسیر
                    تکامل پروژه را دقیقاً دنبال کنند. در حقیقت Version Control از پروژه مثل یک <span class="text_bold">خط زمانی مستند</span>
                    نگهداری
                    می‌کند تا هیچ تغییری بدون تاریخچه و توضیح باقی نماند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">کنترل نسخه دقیقاً چه کاربردهایی دارد؟</h2>
            </header>

            <section class="about-text">
                <p>در ساده‌ترین حالت، کنترل نسخه مجموعه‌ای از امکانات را فراهم می‌کند که در توسعه‌ی واقعی بسیار حیاتی
                    هستند:
                </p>
                <p>
                <ul style="margin-right: 25px">
                    <li>- امکان<span class="text_bold"> بازگرداندن پروژه به نسخه‌های قبل</span> در صورت اشتباه یا خراب
                        شدن کد
                    </li>
                    <li>- <span class="text_bold">بررسی تغییرات انجام شده</span> و فهم اینکه دقیقاً چه چیزی تغییر کرده
                        است
                    </li>
                    <li>- <span class="text_bold">ذخیره‌ی تاریخچه</span>‌ی رشد پروژه و تصمیمات توسعه‌</li>
                    <li>- <span class="text_bold">همکاری همزمان چند برنامه‌نویس</span> روی یک پروژه بدون تداخل و آشفتگی
                    </li>
                    <li>- داشتن <span class="text_bold">نسخه‌های متعدد</span> بدون کپی‌کاری دستی فایل‌ها</li>
                </ul>
                </p>
                <p>
                    برای درک اهمیت آن کافیست شرایطی را تصور کنیم که فردی بخشی از پروژه را تغییر داده اما بعد مشخص شده که
                    این تغییر اشتباه بوده است. بدون Version Control برگشت به حالت قبل دردسر زیادی دارد و گاهی تقریباً
                    ناممکن است. اما با سیستم کنترل نسخه، تنها با یک فرمان می‌توان پروژه را به هر نقطه از گذشته
                    بازگرداند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">روش‌های رایج قبل از سیستم‌های حرفه‌ای کنترل نسخه</h2>
            </header>

            <section class="about-text">
                <p>
                    قبل از وجود ابزارهای مدرن، بسیاری از افراد از راهکارهای ابتدایی برای ذخیره و نگهداری نسخه‌ها استفاده
                    می‌کردند؛
                    مانند ایجاد چند پوشه با نام‌های مختلف:
                </p>
                <div class="code-example" dir="ltr">
                    project-v1<br>
                    project-v2-final<br>
                    project-v2-final-fixed<br>
                    project-final-original-last-this-is-the-final
                </div>
                <p>
                    این روش ساده به نظر می‌رسد اما به شدت <span class="text_bold">خطاپذیر و غیرقابل اعتماد</span> است.
                    نام‌گذاری‌ها به مرور پیچیده
                    می‌شوند، پیدا کردن نسخه صحیح سخت می‌شود و کوچک‌ترین بی‌دقتی می‌تواند منجر به از دست رفتن اطلاعات یا
                    جایگزینی اشتباه فایل‌ها شود.
                    <br><br>
                    پس از این دوره، ابزارهایی به نام <span class="text_bold">Local Version Control</span> معرفی شدند که
                    تاریخچه نسخه‌ها را روی همان
                    سیستم ذخیره می‌کردند. این ابزارها نسبت به روش دستی بسیار بهتر بودند اما همچنان یک مشکل اساسی داشتند:
                    اگر سیستم خراب می‌شد، <span class="text_bold">تمام تاریخچه از بین می‌رفت</span>. همچنین همکاری تیمی
                    همچنان دشوار بود.
                    <br><br>
                    بعد از آن <span class="text_bold">Centralized Version Control Systems (CVCS)</span> معرفی شدند. در
                    این روش، یک <span class="text_bold">سرور مرکزی</span> وجود داشت
                    که تمام نسخه‌های پروژه در آن ذخیره می‌شد و برنامه‌نویسان فایل‌ها را از آن دریافت کرده و سپس تغییرات
                    جدید را به سرور ارسال می‌کردند. این روش نظم بیشتری ایجاد کرد و امکان همکاری چند نفره را فراهم ساخت
                    اما یک ضعف بزرگ داشت: اگر <span class="text_bold">سرور مرکزی دچار مشکل می‌شد یا از دسترس خارج می‌گردید</span>،
                    پروژه عملاً متوقف
                    می‌شد و حتی احتمال از دست رفتن اطلاعات نیز وجود داشت.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">Git و Distributed Version Control — راه‌حل مدرن دنیا
                </h2>
            </header>

            <section class="about-text">
                <p>
                    برای حل این مشکلات، سیستم‌های کنترل نسخه‌ی <span class="text_bold">توزیع‌شده (DVCS)</span> معرفی
                    شدند و <span class="text_bold">Git</span> محبوب‌ترین آن‌هاست.
                    تفاوت اصلی DVCS با سیستم‌های قبلی در این است که این بار تنها یک سرور مرکزی وجود ندارد؛ بلکه هر
                    توسعه‌دهنده هنگام <span class="text_bold">Clone</span> کردن پروژه، یک <span class="text_bold">نسخه کامل از تمام تاریخچه</span>
                    پروژه را دریافت می‌کند. این یعنی هر
                    نسخه‌ی محلی (Local Repository) خود یک نسخه‌ی کامل و مستقل از پروژه است.
                </p>
                <p>مزیت بزرگ این معماری:</p>
                <p>
                <ul style="margin-right: 25px">
                    <li>
                        - <span class="text_bold">عدم وجود نقطه شکست واحد</span><br>
                        اگر سرور خراب شود یا اینترنت قطع باشد، پروژه همچنان روی سیستم توسعه‌دهنده موجود است.
                    </li>
                    <li>
                        - <span class="text_bold">کارکرد کاملاً آفلاین</span><br>
                        برنامه‌نویس حتی بدون اینترنت می‌تواند Commit‌ بزند، Branch بسازد و تاریخچه را مشاهده کند.
                    </li>
                    <li>
                        - <span class="text_bold">سرعت بالا</span> و مدیریت بهینه‌ی فایل‌ها
                    </li>
                    <li>
                        - مناسب برای پروژه‌های <span class="text_bold">کوچک تا بسیار بزرگ</span>
                        از پروژه‌های دانشجویی تا توسعه‌ی هسته لینوکس!
                    </li>
                    <li>
                        - امکان ساخت Branch برای توسعه‌ی ویژگی‌های جدید بدون تاثیر روی کد اصلی
                    </li>
                    <li>
                        - توانایی Merge کردن و مدیریت Conflict به صورت حرفه‌ای
                    </li>
                </ul>
                </p>
                به همین دلیل Git به <span class="text_bold">استاندارد اصلی صنعت</span> تبدیل شده است. تقریباً تمام
                شرکت‌‌ها، تیم‌های توسعه و حتی
                پروژه‌های آزاد به Git وابسته‌اند و اگر قصد فعالیت حرفه‌ای در دنیای نرم‌افزار دارید، یادگیری Git نه
                یک مزیت، بلکه یک <span class="text_bold">الزام</span> است.

            </section>

            <header>
                <h2 id="titr-2" class="h2 article-title">۰.۲ - Git چیست؟</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی شروع به یادگیری Git می‌کنید، لازم است ذهن خود را از آنچه ممکن است دربارهٔ سیستم‌های کنترل نسخه
                    (مثل CVS یا Subversion) شنیده باشید، پاک کنید. چرا که <span class="text_bold">Git بر پایهٔ منطق متفاوتی طراحی شده است</span>
                    و اگر
                    آن
                    را مانند سیستم‌های قدیمی فرض کنید، ممکن است دچار سردرگمی شوید.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">Git با <span class="text_bold">اسنپ‌شات</span> کار می‌کند، نه با "لیست
                    تغییرات"</h2>
            </header>

            <section class="about-text">
                <p>
                    بیشتر سیستم‌های کنترل نسخه سنتی، تغییرات را به‌صورت فهرستی از دلتاها (تغییرات بین نسخه‌ها) ثبت
                    می‌کنند.
                    یعنی ذخیره‌سازی به‌صورت «فایل در نسخه قبلی» + «تغییرات نسبت به آن» است.
                </p>
                <p>
                    اما Git متفاوت است: هر بار که شما <span class="text_bold">commit</span> می‌کنید، Git در واقع یک "عکس
                    فوری (snapshot)" از <span class="text_bold">کل محتوای پروژه در آن لحظه</span>
                    و ذخیره می‌کند. اگر فایلی تغییر نکرده باشد، Git دوباره آن را ذخیره نمی‌کند — فقط
                    لینک
                    به همان نسخه قبلی نگه می‌دارد.
                </p>
                <p>
                    این یعنی Git پروژه را مانند یک فایل‌سیستم بسیار سبک اما با امکانات کامل version control در نظر
                    می‌گیرد؛
                    نه صرفاً مجموعه‌ای از تغییرات.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">بیشتر عملیات Git به‌صورت <span class="text_bold">محلی</span> انجام می‌شود
                </h2>
            </header>

            <section class="about-text">
                <p>
                    یکی از ویژگی‌های مهم Git این است که <span class="text_bold">تقریباً تمام عملیات</span> (مثل commit،
                    مشاهده تاریخچه، بازگرداندن،
                    branch و merge)
                    <span class="text_bold">روی کامپیوتر شخصی (local) انجام می‌شود</span>. نیازی نیست برای هر تغییر به
                    سرور مرکزی متصل باشید.
                </p>
                <p>این مزیت باعث می‌شود:</p>
                <p>
                <ul style="margin-right: 25px">
                    <li>- کارها با <span class="text_bold">سرعت خیلی بالا</span> انجام شوند</li>
                    <li>
                        - حتی در حالت <span class="text_bold">آفلاین</span> (بدون دسترسی به اینترنت) بتوانید کد بنویسید،
                        commit بزنید و تاریخچه را
                        مدیریت کنید.
                    </li>
                    <li>
                        - در صورت وجود سرور مرکزی هم — اگر سرور از کار بیفتد یا اینترنت قطع شود — <span
                            class="text_bold">هیچ نگرانی بابت از دست رفتن تاریخچه ندارید</span>؛ چون تمام تاریخچه
                        به‌صورت محلی محفوظ است.
                    </li>
                </ul>
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">Git ایمن و با «تمامیت داده» (Integrity) بالا است</h2>
            </header>

            <section class="about-text">
                <p>
                    Git طوری طراحی شده که محتویات فایل‌ها و پروژه را با <span class="text_bold">هش (hash)</span> ذخیره
                    کند — یعنی محتوای واقعی فایل مهم
                    است،
                    نه فقط نام آن. اگر محتوای فایل تغییر کند، هش آن متفاوت می‌شود. این ویژگی کمک می‌کند تا تغییرات
                    به‌صورت دقیق
                    ردیابی شوند، و اگر فایلی خراب یا تغییر غیرمجاز داده شود، Git آن را تشخیص می‌دهد.
                </p>
                <p>
                    همچنین، Git تقریباً همه داده‌ها را «می‌افزاید» (append-only)؛ یعنی <span class="text_bold">تاریخچه قابل بازیابی است</span>
                    و
                    تغییرهایی که
                    ثبت شدند، به‌راحتی قابل پاک شدن یا از بین رفتن نیستند — مگر عمداً چنین کاری کنید.
                </p>
                <p>
                    به همین دلیل Git برای پروژه‌هایی که امنیت تاریخچه، قابلیت بازگشت، و شفافیت مهم است — بسیار مناسب
                    است.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">سه حالت اصلی در Git (Working Directory, Staging Area, Repository)</h2>
            </header>

            <section class="about-text">
                <p>در Git، فایل‌ها می‌توانند در یکی از <span class="text_bold">سه حالت</span> باشند:</p>
                <ul style="margin-right: 25px">
                    <li>
                        <span class="text_bold">Modified</span>: فایل را ویرایش کرده‌اید، اما هنوز آن را برای commit
                        آماده نکرده‌اید.
                    </li>
                    <li>
                        <span class="text_bold">Staged</span>: تغییرات فایل انتخاب شده‌اند تا در commit بعدی ثبت شوند
                        (در اصطلاح، به
                        منطقه staging اضافه شدند).
                    </li>
                    <li>
                        <span class="text_bold">Committed</span>: فایل و تغییرات آن با مؤلفه‌های کامل (مثل تاریخ و نام
                        کاربر) در
                        تاریخچه مخزن ذخیره شدند.
                    </li>
                </ul>
                <p>روند کار معمول Git بدین صورت است: </p>
                <ul style="margin-right: 25px">
                    <li>شما روی فایل‌ها کار می‌کنید (ویرایش، حذف، اضافه).</li>
                    <li>وقتی آماده بودید، تغییرات را Stage می‌کنید (<span class="text_bold">git add …</span>).</li>
                    <li>
                        سپس commit می‌کنید (<span class="text_bold">git commit -m "پیام مناسب"</span>)، که آن وضعیت را
                        به صورت snapshot در تاریخچه
                        ذخیره می‌کند.
                    </li>
                </ul>
            </section>

            <header>
                <h2 class="h2 article-title">Git به‌عنوان یک سیستم توزیع‌شده (Distributed Version Control)</h2>
            </header>

            <section class="about-text">
                <p>
                    نکتهٔ مهم و بنیادین در Git این است که این یک سیستم <span class="text_bold">توزیع‌شده (DVCS)</span>
                    است. یعنی وقتی شما یک مخزن
                    (repository)
                    را <span class="text_bold">clone</span> می‌کنید، در واقع <span class="text_bold">کل تاریخچه و اطلاعات پروژه را روی سیستم خود دارید</span>
                    — نه فقط یک نسخه ساده.
                </p>
                <p>این به معنی آن است که:</p>
                <ul style="margin-right: 25px">
                    <li>
                        <span class="text_bold">حتی اگر به سرور مرکزی دسترسی نداشته باشید</span>، باز هم می‌توانید
                        commit بزنید، شاخه (<span class="text_bold">branch</span>) بسازید
                        و تاریخچه را مرور کنید.
                    </li>
                    <li>
                        - خطر از بین رفتن تاریخچه در صورت خرابی سرور یا قطعی اینترنت <span class="text_bold">به حداقل می‌رسد</span>،
                        چون تاریخچه روی
                        چند کامپیوتر توزیع شده است.
                    </li>
                    <li>
                        - همکاری تیمی <span class="text_bold">انعطاف‌پذیر و سریع‌تر</span> می‌شود: افراد می‌توانند
                        به‌صورت مستقل روی شاخه‌های مختلف کار
                        کنند و سپس تغییراتشان را با هم ترکیب (merge) کنند.
                    </li>
                </ul>
            </section>

            <header>
                <h2 id="titr-3" class="h2 article-title">۰.۳ - نصب Git روی سیستم‌عامل‌های مختلف</h2>
            </header>

            <section class="about-text">
                <p>
                    برای شروع کار با Git، ابتدا باید آن را روی سیستم نصب کنیم. Git یک <span class="text_bold">ابزار چندسکویی</span>
                    است و روی اکثر
                    سیستم‌عامل‌ها قابل اجراست. روش نصب در هر سیستم متفاوت است اما معمولاً ساده و سریع انجام می‌شود.
                    در این فصل، گام‌به‌گام یاد می‌گیریم چگونه Git را روی Windows، Linux و macOS نصب و اجرا کنیم.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">نصب Git روی ویندوز (Windows)</h2>
            </header>

            <section class="about-text">
                <p>سیستم‌عامل ویندوز به صورت پیش‌فرض Git ندارد، بنابراین باید آن را دانلود و نصب کنیم.</p>
                <p><span class="text_bold">مراحل نصب:</span></p>
                <ul style="margin-right: 25px">
                    <li>ورود به <span class="text_bold">سایت رسمی Git: git-scm.com</span></li>
                    <li>دانلود نسخه مناسب ویندوز</li>
                    <li>اجرای فایل نصب (.exe)</li>
                    <li>در مراحل نصب، گزینه‌ها را <span class="text_bold">پیش‌فرض بگذارید</span> مگر اینکه نیاز خاصی
                        داشته باشید.
                    </li>
                    <li>گزینه <span class="text_bold">Git Bash</span> را فعال بگذارید — این ابزار ترمینال مخصوص Git است.
                    </li>
                    <li>در پایان، Finish را بزنید.</li>
                </ul>
                <p><span class="text_bold">تست نصب:</span></p>
                <p>بعد از نصب، Git Bash یا CMD را باز کنید و بنویسید:</p>
                <div class="code-example" dir="ltr">
                    git --version
                </div>
                <p>اگر شماره نسخه نمایش داده شد، نصب موفق بوده است.</p>
            </section>

            <header>
                <h2 class="h2 article-title">نصب Git روی macOS</h2>
            </header>

            <section class="about-text">
                <p>کاربران macOS سه روش برای نصب دارند:</p>
                <p><span class="text_bold">روش ۱ — نصب اتوماتیک از طریق Terminal (ساده‌ترین راه)</span></p>
                <p>ترمینال را باز کنید و دستور زیر را اجرا کنید:</p>
                <div class="code-example" dir="ltr">
                    git --version
                </div>
                <p>
                    اگر Git نصب نباشد، سیستم پنجره‌ای باز می‌کند و پیشنهاد <span class="text_bold">نصب Xcode Command Line Tools</span>
                    را می‌دهد.
                    فقط Install را بزنید.
                </p>

                <p>* این روش سریع‌ترین است و بیشتر کاربران همین را انتخاب می‌کنند.</p>
                <p><span class="text_bold">روش ۲ — نصب با Homebrew</span></p>
                <p>اگر Homebrew دارید (یا قصد دارید حرفه‌ای‌تر کار کنید):</p>
                <div class="code-example" dir="ltr">
                    brew install git
                </div>
                <p><span class="text_bold">روش ۳ — نصب از طریق وب‌سایت رسمی</span></p>
                <ul style="margin-right: 25px">
                    <li>ورود به: git-scm.com</li>
                    <li>دانلود نسخه macOS</li>
                    <li>نصب مانند برنامه‌های معمولی</li>
                </ul>
            </section>

            <header>
                <h2 class="h2 article-title">نصب Git روی لینوکس</h2>
            </header>

            <section class="about-text">
                <p>در بسیاری از توزیع‌های لینوکس Git از قبل نصب است. ابتدا بررسی کنید:</p>
                <div class="code-example" dir="ltr">
                    git --version
                </div>
                <p>اگر نصب نبود، بسته به توزیع، یکی از دستورات زیر را اجرا کنید:</p>
                <p><span class="text_bold">Debian / Ubuntu</span></p>
                <div class="code-example" dir="ltr">
                    sudo apt update<br>
                    sudo apt install git
                </div>
                <p><span class="text_bold">Fedora</span></p>
                <div class="code-example" dir="ltr">
                    sudo dnf install git
                </div>
                <p><span class="text_bold">Arch Linux</span></p>
                <div class="code-example" dir="ltr">
                    sudo pacman -S git
                </div>
            </section>

            <header>
                <h2 class="h2 article-title">تست نهایی نصب روی هر سیستم</h2>
            </header>

            <section class="about-text">
                <p>بعد از نصب، برای اطمینان از آماده بودن محیط کار، چند دستور اولیه اجرا کنید:</p>
                <div class="code-example" dir="ltr">
                    git --version # نمایش نسخه گیت<br>
                    git config --list # نمایش تنظیمات پیکربندی
                </div>
                <p>اگر خروجی نمایش داده شد، Git آماده استفاده است.</p>
            </section>

            <header>
                <h2 class="h2 article-title">نکات و مشکلات رایج</h2>
            </header>

            <section class="about-text">
                <ul>
                    <li>- اگر git در CMD اجرا نمی‌شود، مسیر PATH تنظیم نشده — Git Bash را تست کنید.</li>
                    <li>- روی macOS معمولاً نیاز به Command Line Tools است.</li>
                    <li>- روی لینوکس گاهی باید بسته‌های وابسته را آپدیت کنید.</li>
                    <li>
                        - پس از نصب، فراموش نکنید فصل "ستاپ اولیه Git" را انجام دهید:
                        <div class="code-example" dir="ltr" style="margin-top: 10px; margin-bottom: 10px;">
                            git config --global user.name "Your Name"<br>
                            git config --global user.email "youremail@example.com"
                        </div>
                    </li>
                </ul>
            </section>

            <header>
                <h2 id="titr-4" class="h2 article-title">۰.۴ – ستاپ اولیه Git</h2>
            </header>

            <section class="about-text">
                <p>
                    پس از نصب Git روی کامپیوتر، برای اینکه Git برای شما به درستی کار کند — باید <span class="text_bold">چند تنظیم پایه</span>
                    انجام
                    دهید.
                    این تنظیمات را معمولاً <span class="text_bold">یک بار در هر سیستم</span> انجام می‌دهیم و برای تمام
                    مخازنی (repositories) که در آن
                    سیستم
                    ایجاد می‌کنیم، اعمال می‌شوند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">چرا تنظیم اولیه مهم است؟</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی commit می‌زنید، <span
                        class="text_bold">Git اطلاعات هویت شما (نام و ایمیل) را ذخیره می‌کند</span> — این اطلاعات بعداً
                    در
                    تاریخچه
                    commitها می‌ماند.
                </p>
                <p>
                    اگر ویرایشگر پیش‌فرض Git را مشخص نکنید، هر زمان که Git منتظر نوشتن پیام commit شود (یا برای ادغام)،
                    ممکن است
                    Git شما را درگیر ویرایشگر پیش‌فرض سیستم کند که برای تازه‌کارها گیج‌کننده است.
                </p>
                <p>
                    اگر نیاز دارید شاخه (branch) پیش‌فرض متفاوتی برای مخازن جدید تعیین کنید (مثلاً به جای "master" از
                    "main"
                    استفاده کنید)، این تنظیم هم از طریق config قابل انجام است.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">تنظیمات پایه — دستورات لازم</h2>
            </header>

            <section class="about-text">
                <p><span class="text_bold">تنظیم هویت (Name & Email)</span></p>
                <div class="code-example" dir="ltr">
                    git config --global user.name "Your Name"<br>
                    git config --global user.email "youremail@example.com"
                </div>
                <p>
                    این دستورها <span class="text_bold">نام و ایمیل شما را به‌صورت سراسری</span> روی سیستم تعریف
                    می‌کنند. بعد از این، هر commit شما با
                    همین
                    نام و ایمیل ثبت خواهد شد.
                </p>
                <p>
                    اگر بخواهید برای یک پروژه مشخص نام یا ایمیل متفاوتی تنظیم کنید، کافی است همان دستور را <span
                        class="text_bold">بدون گزینه
        --global</span>
                    داخل پوشه‌ی آن پروژه اجرا کنید.
                </p>
                <p><span class="text_bold">تنظیم ویرایشگر پیش‌فرض برای Git</span></p>
                <p>
                    اگر می‌خواهید هنگام نوشتن پیام commit یا در مواقعی که Git نیاز به ویرایشگر دارد (مثلاً merge) راحت
                    باشید:
                </p>
                <div class="code-example" dir="ltr">
                    git config --global core.editor nano # (یا vim, code, notepad++ و غیره)
                </div>
                <p>
                    اگر این تنظیم را انجام ندهید، Git از ویرایشگر پیش‌فرض سیستم استفاده می‌کند — که ممکن است برای همه
                    مناسب نباشد.
                </p>
                <p><span class="text_bold">تعیین نام شاخه پیش‌فرض برای مخازن جدید</span></p>
                <p>
                    از نسخه‌ی ۲٫۲۸ به بعد Git به شما اجازه می‌دهد شاخه پیش‌فرض مخزن جدید را به دلخواه تعیین کنید
                    (مثلاً "main" به جای "master"):
                </p>
                <div class="code-example" dir="ltr">
                    git config --global init.defaultBranch main
                </div>
                <p>
                    با این کار، وقتی git init یا ساخت مخزن جدید انجام شود، شاخه اصلی با نام تنظیم‌شده ایجاد می‌شود.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title">چک کردن تنظیمات</h2>
            </header>

            <section class="about-text">
                <p>برای دیدن <span class="text_bold">تمام تنظیماتی</span> که Git الان برای شما فعال کرده است:</p>
                <div class="code-example" dir="ltr">
                    git config --list
                </div>
                <p>اگر بخواهید بدانید مقدار یک تنظیم خاص چیست:</p>
                <div class="code-example" dir="ltr">
                    git config user.name<br>
                    git config user.email
                </div>
                <p>همچنین برای دیدن اینکه هر تنظیم از کدام فایل گزینه خوانده شده است:</p>
                <div class="code-example" dir="ltr">
                    git config --list --show-origin
                </div>
                <p>
                    این کار به شما کمک می‌کند تا اگر تنظیمی را اشتباه داده‌اید یا می‌خواهید ببینید دقیقاً کدام فایل
                    پیکربندی
                    (global, system, local) آن را نگه داشته است.
                </p>
            </section>

            <header>
                <h2 id="titr-5" class="h2 article-title">جمع‌بندی فصل</h2>
            </header>

            <section class="about-text">
                <p>در این فصل با مفاهیم <span class="text_bold">پایه‌ای و پیش‌نیازهای</span> ورود به دنیای Git آشنا
                    شدیم. ابتدا دریافتیم که <span class="text_bold">کنترل نسخه (Version Control)</span> چیست و چرا در
                    توسعه نرم‌افزار اهمیت دارد. فهمیدیم که بدون وجود سیستم‌های کنترل نسخه، <span class="text_bold">مدیریت تغییرات، پیگیری تاریخچه پروژه و همکاری تیمی</span>
                    کاری دشوار و گاهی غیرممکن می‌شود.</p>

                <p>سپس <span class="text_bold">Git</span> را به‌عنوان یکی از <span class="text_bold">محبوب‌ترین و قدرتمندترین</span>
                    ابزارهای کنترل نسخه معرفی کردیم؛ ابزاری که <span class="text_bold">توزیع‌شده</span> است، <span
                            class="text_bold">سرعت بالایی</span> دارد و امروزه در اغلب شرکت‌ها و پروژه‌های متن‌باز مورد
                    استفاده قرار می‌گیرد.</p>

                <p>در ادامه یاد گرفتیم چگونه Git را بسته به سیستم‌عامل خود <span class="text_bold">نصب کنیم</span> — چه
                    از طریق دانلود مستقیم روی ویندوز، چه نصب با Homebrew یا ابزارهای Command Line در macOS، و همچنین
                    مخازن بسته در توزیع‌های مختلف لینوکس. پس از نصب نیز <span class="text_bold">تنظیمات اولیه</span> را
                    انجام دادیم تا Git بتواند <span class="text_bold">اطلاعات کاربر (نام و ایمیل)</span> را در commitها
                    ثبت کند و تجربه کار حرفه‌ای فراهم شود.</p>

                <p>حال با پایان فصل ۰، <span class="text_bold">محیط کاری ما آماده است</span> و می‌توانیم وارد مباحث عملی
                    شویم. از اینجا به بعد، وارد دنیای واقعی Git می‌شویم: <span class="text_bold">ساخت اولین مخزن، انجام commit، مشاهده تاریخچه و شروع workflow واقعی توسعه</span>.
                    در فصل آینده قدم‌به‌قدم Git را در عمل لمس خواهیم کرد و اولین پروژه خود را با این ابزار قدرتمند
                    نسخه‌بندی می‌کنیم.</p>
            </section>
        </article>

        <article class="resume " data-page="فصل ۱">
            <h2 class="h2 article-title">فصل ۱: مقدمات گیت</h2>

            <ul class="article-list code-example" style="margin-bottom: 24px">
                <li><span>فهرست مطالب فصل</span></li>
                <li><a href="#titr-1.1">۱.۱ - گرفتن یا ساخت یک مخزن Git</a></li>
                <li><a href="#titr-1.2">۱.۲ - ثبت تغییرات در مخزن</a></li>
                <li><a href="#titr-1.3">۱.۳ - مشاهده تاریخچه کامیت‌ها</a></li>
                <li><a href="#titr-1.4">۱.۴ – بازگرداندن تغییرات</a></li>
                <li><a href="#titr-1.5">۱.۵ – کار کردن با ریموت‌ها</a></li>
                <li><a href="#titr-1.6">۱.۶ – جمع‌بندی فصل</a></li>
            </ul>

            <header>
                <h2 id="titr-1.1" class="h2 article-title">فصل ۱.۱ – گرفتن یا ساخت یک مخزن Git</h2>
            </header>

            <section class="about-text">
                <p>
                    قبل از اینکه بتوانیم از Git استفاده کنیم — یعنی تغییرات را ثبت کنیم، تاریخچه داشته باشیم، شاخه
                    بسازیم و … —
                    نیاز است پروژه‌مان زیر نظر <span class="text_bold">Git</span> باشد. این یعنی ما باید یک <span
                        class="text_bold">مخزن Git</span> ایجاد کنیم یا یک مخزن آماده را کپی (<span class="text_bold">clone</span>)
                    کنیم. مخزن جایی است که Git تمام اطلاعات <span class="text_bold">تاریخچه، شاخه‌ها، کامیت‌ها، و metadata</span>
                    پروژه را ذخیره می‌کند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> دو راه برای داشتن مخزن Git</h2>
            </header>

            <section class="about-text">
                <p>شما معمولاً <span class="text_bold">دو روش</span> برای به‌دست آوردن یک مخزن Git دارید:</p>
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">ساخت مخزن جدید</span> در یک پوشه محلی موجود (برای پروژه‌هایی که خودتان
                        شروع می‌کنید)
                    </li>
                    <li><span class="text_bold">کلون کردن (clone)</span> یک مخزن Git موجود (مثلاً پروژه‌ای از GitHub یا
                        سرور دیگر، برای مشارکت یا استفاده)
                    </li>
                </ul>
            </section>

            <header>
                <h2 class="h2 article-title"> روش اول — ساخت مخزن در پوشه محلی</h2>
            </header>

            <section class="about-text">
                <p>اگر پروژه‌ای دارید و می‌خواهید آن را زیر کنترل Git ببرید:</p>
                <p>ابتدا وارد پوشه پروژه شوید. مثلاً در ویندوز:</p>
                <div class="code-example" dir="ltr">
                    cd C:/path/to/your-project
                </div>
                <p>یا در لینوکس / مک:</p>
                <div class="code-example" dir="ltr">
                    cd /home/user/your-project
                </div>
                <p>سپس دستور زیر را اجرا کنید:</p>
                <div class="code-example" dir="ltr">
                    git init
                </div>
                <p>
                    این دستور یک <span class="text_bold">زیرپوشه مخفی به نام .git</span> در پروژه ایجاد می‌کند — ساختار
                    داخلی Git که تمام تاریخچه و تنظیمات
                    لازم را نگه می‌دارد.
                </p>
                <p>
                    تا اینجا پروژه شما تحت کنترل نسخه قرار گرفته، اما هنوز هیچ فایلی <span class="text_bold">«ردیابی» (tracked) نشده</span>
                    است. برای شروع
                    کنترل فایل‌ها، باید آن‌ها را <span class="text_bold">اضافه (stage) و در اولین commit ثبت</span>
                    کنید:
                </p>
                <div class="code-example" dir="ltr">
                    git add . # اضافه کردن همه فایل‌ها<br>
                    git commit -m "Initial commit" # اولین commit
                </div>
                <p>
                    با این کار، تمام فایل‌های فعلی پروژه <span class="text_bold">تحت نظر Git</span> قرار می‌گیرند و یک
                    نقطه شروع برای تاریخچه پروژه ایجاد می‌شود.
                </p>
                <p><span class="text_bold">نتیجه:</span> اکنون یک مخزن Git کامل دارید، با اولین commit و آماده برای
                    ادامه کار.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> روش دوم — clone کردن یک مخزن موجود</h2>
            </header>

            <section class="about-text">
                <p>اگر می‌خواهید روی پروژه‌ای که قبلاً با Git ساخت شده کار کنید، کافی است آن را <span class="text_bold">clone</span>
                    کنید:</p>
                <div class="code-example" dir="ltr">
                    git clone &lt;repository_url&gt;
                </div>
                <p>مثلاً:</p>
                <div class="code-example" dir="ltr">
                    git clone https://github.com/username/project-name.git
                </div>
                <p>این فرمان:</p>
                <ul style="margin-right: 25px">
                    <li>یک پوشه جدید به نام پروژه ایجاد می‌کند</li>
                    <li>داخل آن .git را تنظیم می‌کند</li>
                    <li><span class="text_bold">تمام تاریخچه پروژه</span> (کامیت‌ها، شاخه‌ها، داده‌ها) را دانلود می‌کند
                    </li>
                    <li><span class="text_bold">آخرین نسخه کد</span> را برای شما Checkout می‌کند تا بتوانید بلافاصله
                        شروع به کار کنید
                    </li>
                </ul>
                <p>اگر بخواهید پروژه را در پوشه‌ای با نام متفاوت ذخیره کنید:</p>
                <div class="code-example" dir="ltr">
                    git clone &lt;repository_url&gt; my-project-copy
                </div>
                <p>در این صورت پروژه در پوشه my-project-copy خواهد بود.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> نکات مهم بعد از clone یا init</h2>
            </header>

            <section class="about-text">
                <ul style="margin-right: 25px">
                    <li>پس از <span class="text_bold">git init</span> یا <span class="text_bold">git clone</span> پوشه‌ی
                        پروژه آماده است؛ اما اگر init کرده‌اید، فراموش نکنید فایل‌ها را <span class="text_bold">add و commit</span>
                        کنید.
                    </li>
                    <li><span class="text_bold">clone کردن یک repo یعنی شما کل تاریخچه پروژه را دارید</span> — پس حتی
                        اگر سرور اصلی دچار مشکل شود، با کلون محلی پروژه همه داده‌ها محفوظ است.
                    </li>
                    <li>نام شاخه پیش‌فرض ممکن است متفاوت باشد (مثلاً main یا master)؛ بعداً می‌توانید آن را تغییر
                        دهید.
                    </li>
                </ul>
            </section>

            <header>
                <h2 id="titr-1.2" class="h2 article-title">فصل ۱.۲ — ثبت تغییرات در مخزن (Recording Changes to the Repository)</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی یک مخزن Git دارید و فایل‌هایتان را در دایرکتوری کاری دارید، برای ثبت تغییرات باید بدانید که Git
                    چگونه فایل‌ها را <span class="text_bold">رصد می‌کند</span> و چگونه وضعیت آن‌ها را تغییر می‌دهد. در
                    این فصل با مفاهیم «<span class="text_bold">tracked / untracked</span>»، «<span class="text_bold">stage / unstaged</span>»،
                    و روند ثبت تغییرات (<span class="text_bold">add → commit</span>) آشنا می‌شویم.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> وضعیت فایل‌ها در Git
                </h2>
            </header>

            <section class="about-text">
                <p>
                    هر فایل در پروژه یا <span class="text_bold">tracked</span> است (یعنی Git آن را می‌شناسد) یا <span
                        class="text_bold">untracked</span> (فایل جدید یا فایل‌هایی که Git هنوز به آن‌ها نگاه نکرده).
                </p>
                <p>
                    وقتی برای اولین بار مخزن را clone می‌کنید، تمام فایل‌ها <span
                        class="text_bold">tracked و بدون تغییر</span> هستند (چون Git آن‌ها را از مخزن دریافت کرده)؛ اگر
                    فایلی اضافه کنید، ابتدا <span class="text_bold">Untracked</span> است تا وقتی خودتان آن را به صراحت
                    <span class="text_bold">اضافه (stage)</span> کنید.
                </p>
            </section>

            <img src="../assets/img/lifecycle.png" alt="lifecycle" style="width: 100%; margin: 20px 0">

            <header>
                <h2 class="h2 article-title"> آماده‌سازی برای ثبت: <span class="text_bold">git add</span> — دنبال کردن
                    یا مرحله‌بندی</h2>
            </header>

            <section class="about-text">
                <p>
                    اگر بخواهید فایل جدید را به مخزن اضافه کنید یا تغییرات فایل‌های موجود را در commit بعدی وارد کنید —
                    باید از:
                </p>
                <div class="code-example" dir="ltr">
                    git add &lt;file-or-directory&gt;
                </div>
                <p>
                    استفاده کنید. این دستور فایل (یا فایل‌ها) را به <span class="text_bold">Stage</span> می‌آورد، به این
                    معنا که Git بداند تغییرات این فایل باید <span class="text_bold">ذخیره شوند</span>.
                </p>
                <p>
                    پس از اجرای git add اگر:
                </p>
                <div class="code-example" dir="ltr">
                    git status
                </div>
                <p>
                    را اجرا کنید، فایل‌های جدید یا تغییر یافته‌ای که <span class="text_bold">stage شده‌اند</span> زیر
                    عنوان <span class="text_bold">"Changes to be committed"</span> دیده می‌شوند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> ویرایش پس از stage — دقت در staging</h2>
            </header>

            <section class="about-text">
                <p>
                    اگر فایلی <span class="text_bold">بعد از stage تغییر کند</span>، Git آن را دوباره به صورت «تغییر
                    نیافته برای commit» لحاظ نمی‌کند؛ یعنی stage با محتوایی که هنگام اجرای <span class="text_bold">git add</span>
                    بوده ذخیره می‌شود. برای commit نهایی، اگر تغییر جدید داده‌اید — <span class="text_bold">دوباره باید git add اجرا کنید</span>.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> بررسی وضعیت مخزن: <span
                        class="text_bold">git status & git status -s</span></h2>
            </header>

            <section class="about-text">
                <p>
                    <span class="text_bold">git status</span> <span class="text_bold">اطلاعات کامل</span>: شاخه فعلی،
                    فایل‌های staged، unstaged، untracked را نشان می‌دهد. این <span class="text_bold">راه اصلی</span>
                    برای فهمیدن وضعیت کنونی پروژه است.
                </p>
                <p>
                    <span class="text_bold">git status -s</span> یا --short نمای جمع و جورتر با علائم اختصاری:
                </p>
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">??</span> ← فایل untracked</li>
                    <li><span class="text_bold">A</span> ← فایل staged (افزودنی جدید)</li>
                    <li><span class="text_bold">M</span> ← فایل modified</li>
                </ul>
                <p>
                    دو ستون دارد: ستون چپ وضعیت <span class="text_bold">stage</span>، ستون راست وضعیت <span
                        class="text_bold">working directory</span>.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> دیدن تغییرات دقیق: <span class="text_bold">git diff</span></h2>
            </header>

            <section class="about-text">
                <p>
                    <span class="text_bold">git diff</span> تفاوت بین <span class="text_bold">working directory</span> و
                    <span class="text_bold">staging area</span> را نشان می‌دهد — خطوطی که تغییر داده‌اید ولی هنوز Stage
                    نکرده‌اید.
                </p>
                <p>
                    اگر بخواهید ببینید چه چیزی برای commit آماده است (<span class="text_bold">staged</span>) نسبت به
                    آخرین commit، از:
                </p>
                <div class="code-example" dir="ltr">
                    git diff --staged
                </div>
                <p>یا</p>
                <div class="code-example" dir="ltr">
                    git diff --cached
                </div>
                <p>استفاده می‌شود.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> نهایی کردن تغییرات: <span class="text_bold">git commit</span></h2>
            </header>

            <section class="about-text">
                <p>
                    بعد از staged کردن فایل‌ها، برای <span class="text_bold">ثبت نهاییت تغییرات در تاریخچه مخزن</span>:
                </p>
                <div class="code-example" dir="ltr">
                    git commit -m "توضیح کوتاه درباره تغییرات"
                </div>
                <p>یا اگر می‌خواهید پیام را در ویرایشگر وارد کنید:</p>
                <div class="code-example" dir="ltr">
                    git commit
                </div>
                <p>
                    ️ <span class="text_bold">Git فقط آن‌چه در staging area هست را در commit ثبت می‌کند</span>. هر
                    تغییری بعد از git add و قبل از git commit ویرایش شود بدون git add مجدد در commit قرار نمی‌گیرد.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> فایل‌های نادیده‌گرفته‌شده: <span class="text_bold">.gitignore</span></h2>
            </header>

            <section class="about-text">
                <p>
                    گاهی فایل‌هایی داریم (مثل فایل‌های ساخته‌شده خودکار، فایل‌های لاگ، build، فایل‌های باینری) که <span
                        class="text_bold">نمی‌خواهیم Git آن‌ها را ردیابی کند</span>. برای این منظور:
                </p>
                <ul style="margin-right: 25px">
                    <li>یک فایل متنی به نام <span class="text_bold">.gitignore</span> در ریشه مخزن می‌سازیم</li>
                    <li>الگوهایی می‌نویسیم که Git آنها را نادیده بگیرد (مثلاً *.log, temp/, node_modules/ ...)</li>
                </ul>
                <p>
                    این کمک می‌کند که مخزن <span class="text_bold">پاک و مرتب</span> بماند و فایل‌های ناخواسته وارد
                    تاریخچه نشوند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> چرخه کار معمول با Git</h2>
            </header>

            <section class="about-text">
                <p>
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">تغییر کد</span> / ایجاد فایل جدید</li>
                    <li><span class="text_bold">git status</span> ← دیدن وضعیت</li>
                    <li><span class="text_bold">git add &lt;files&gt;</span> ← آماده‌سازی برای commit</li>
                    <li>(اختیاری) <span class="text_bold">git diff / git status -s</span> ← بررسی تغییرات</li>
                    <li><span class="text_bold">git commit -m "پیام"</span> ← ثبت تغییرات</li>
                    <li>دوباره شروع: تغییرات جدید ← add ← commit</li>
                </ul>
                </p>
            </section>

            <header>
                <h2 id="titr-1.3" class="h2 article-title">فصل ۱.۳ — مشاهده تاریخچه کامیت‌ها (Viewing the Commit History)</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی در پروژه‌تان چند کامیت ثبت کرده‌اید، یا مخزنی را clone کرده‌اید که پیش از شما تاریخچه دارد،
                    طبیعی است بخواهید «ببینید گذشته پروژه چگونه بوده است»: چه تغییراتی انجام شده، چه زمانی، توسط چه کسی،
                    و با چه پیام‌هایی. برای این بررسی <span class="text_bold">مهم‌ترین ابزار</span> در Git، دستور <span
                        class="text_bold">git log</span> است.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> دستور پایه: <span class="text_bold">git log</span></h2>
            </header>

            <section class="about-text">
                <p>اجرای ساده:</p>
                <div class="code-example" dir="ltr">
                    git log
                </div>
                <p>لیستی <span class="text_bold">معکوس (جدید ← قدیم)</span> از کامیت‌ها نمایش می‌دهد. برای هر کامیت
                    موارد زیر دیده می‌شوند:</p>
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">شناسه (SHA-1) کامیت</span></li>
                    <li><span class="text_bold">نام نویسنده و ایمیل</span></li>
                    <li><span class="text_bold">تاریخ و ساعت</span></li>
                    <li><span class="text_bold">پیام کامیت</span></li>
                </ul>
            </section>

            <header>
                <h2 class="h2 article-title"> گزینه‌ها و حالت‌های مختلف برای مشاهده بهتر تاریخچه</h2>
            </header>

            <section class="about-text">
                <p><span class="text_bold">نمای خلاصه (oneline):</span></p>
                <div class="code-example" dir="ltr">
                    git log --pretty=oneline
                </div>
                <p>هر کامیت در یک خط، شامل <span class="text_bold">شناسه کوتاه + پیام</span></p>

                <p><span class="text_bold">نمای گراف با شاخه‌ها و mergeها (graph):</span></p>
                <div class="code-example" dir="ltr">
                    git log --graph --oneline
                </div>
                <p><span class="text_bold">مناسب وقتی شاخه (branch) و ادغام (merge) زیادی وجود دارد</span> و می‌خواهید
                    ساختار تاریخچه را ببینید. </p>

                <p><span class="text_bold">نمای همراه با تغییرات هر commit (patch):</span></p>
                <div class="code-example" dir="ltr">
                    git log -p
                </div>
                <p>این حالت علاوه بر اطلاعات هر commit، <span class="text_bold">«تفاوت (diff)»</span> بین آن commit و
                    commit قبلی را نشان می‌دهد — یعنی دقیقاً چه خطوطی اضافه یا حذف شده‌اند.</p>

                <p><span class="text_bold">نمای با آمار تغییرات (stat):</span></p>
                <div class="code-example" dir="ltr">
                    git log --stat
                </div>
                <p>لیستی از فایل‌های تغییر یافته + <span class="text_bold">تعداد خطوط اضافه/حذف‌شده</span> زیر هر
                    commit. مناسب برای دید کلی تغییرات بدون جزئیات diff.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> فیلتر و محدود کردن نمایش</h2>
            </header>

            <section class="about-text">
                <p>ممکن است تاریخچه پروژه خیلی طولانی باشد. Git امکاناتی دارد برای <span
                        class="text_bold">فیلتر کردن</span>:</p>

                <p><span class="text_bold">محدود کردن تعداد کامیت‌ها:</span></p>
                <div class="code-example" dir="ltr">
                    git log -n 5     # 5 کامیت آخر<br>
                    git log -2       # 2 کامیت آخر
                </div>

                <p><span class="text_bold">فیلتر بر اساس تاریخ:</span></p>
                <div class="code-example" dir="ltr">
                    git log --since="2025-10-01"<br>
                    git log --until="2025-11-15"
                </div>

                <p><span class="text_bold">فیلتر بر اساس نویسنده:</span></p>
                <div class="code-example" dir="ltr">
                    git log --author="Ali"
                </div>
                <p>فقط کامیت‌هایی که نویسنده‌شان «Ali» است نمایش داده می‌شوند.</p>

                <p><span class="text_bold">جستجو در پیام commit:</span></p>
                <div class="code-example" dir="ltr">
                    git log --grep="fix bug"
                </div>
                <p>کامیت‌هایی که در پیامشان «fix bug» آمده را نمایش می‌دهد.</p>

                <p><span class="text_bold">جستجو بر اساس تغییرات در کد (pickaxe):</span></p>
                <div class="code-example" dir="ltr">
                    git log -S functionName
                </div>
                <p>کامیت‌هایی که <span class="text_bold">اضافه/حذف «functionName»</span> در آن‌ها اتفاق افتاده را نمایش
                    می‌دهد.</p>

                <p><span class="text_bold">محدود کردن بر اساس مسیر یا فایل خاص:</span></p>
                <div class="code-example" dir="ltr">
                    git log -- path/to/file
                </div>
                <p>فقط کامیت‌هایی نمایش داده می‌شوند که <span class="text_bold">فایل مشخص‌شده</span> در آن‌ها تغییر کرده
                    باشد.</p>
            </section>

            <header>
                <h2 id="titr-1.4" class="h2 article-title">فصل ۱.۴ — بازگرداندن تغییرات (<span class="text_bold">Undoing Things</span>)
                </h2>
            </header>

            <section class="about-text">
                <p>
                    گاهی در هنگام کار با Git ممکن است بخواهیم تغییراتی را که داده‌ایم — چه در «<span class="text_bold">Stage</span>»،
                    چه در «<span class="text_bold">Working Directory</span>»، یا حتی در «<span class="text_bold">تاریخچه (Commit)</span>»
                    — <span class="text_bold">لغو کنیم</span>. این فصل به مهم‌ترین روش‌های <span
                        class="text_bold">Undo</span> می‌پردازد.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> اصلاح آخرین Commit
                </h2>
            </header>

            <section class="about-text">
                <p>
                    اگر بعد از commit به اشتباه، متوجه شدید که <span
                        class="text_bold">فایل‌هایی فراموش کردید add کنید</span> یا <span class="text_bold">پیام commit مناسب نیست</span>،
                    می‌توانید با:
                </p>
                <div class="code-example" dir="ltr">
                    git commit --amend
                </div>
                <p><span class="text_bold">آخرین commit را بازنویسی کنید</span>. با این کار:</p>
                <ul style="margin-right: 25px">
                    <li>اگر تغییری در staging area باشد → آن‌ها هم <span
                            class="text_bold">به commit اضافه می‌شوند</span>.
                    </li>
                    <li>اگر هیچ تغییری بین commit و اجرا نکردن این دستور نباشد → <span class="text_bold">تنها پیام commit تغییر می‌کند</span>.
                    </li>
                </ul>
                <p>⚠ <span class="text_bold">توجه مهم</span>: این روش فقط برای commit‌هایی مناسب است که <span
                        class="text_bold">هنوز Push نشده‌اند</span>. بازنویسی commit‌های ارسال‌شده می‌تواند برای همکاری
                    تیمی خطرناک باشد.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> خارج کردن فایل از Stage (<span class="text_bold">Unstage</span>) — زمانی
                    که اشتباهی git add زدید</h2>
            </header>

            <section class="about-text">
                <p>
                    فرض کنید تغییراتی داده‌اید و با <span class="text_bold">git add</span> مرحله‌بندی (stage) کرده‌اید،
                    اما می خواهید آن‌ها را از Stage خارج کنید — برای این کار:
                </p>
                <div class="code-example" dir="ltr">
                    git reset HEAD &lt;file&gt;
                </div>
                <p>یا در نسخه‌های جدید Git:</p>
                <div class="code-example" dir="ltr">
                    git restore --staged &lt;file&gt;
                </div>
                <p>به این ترتیب فایل <span class="text_bold">به حالت Unstaged باز می‌گردد</span>.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> لغو تغییرات محلی — <span class="text_bold">برگرداندن فایل به آخرین نسخه Commit شده</span>
                </h2>
            </header>

            <section class="about-text">
                <p>
                    اگر فایلی را ویرایش کرده‌اید ولی تصمیم دارید تغییرات را <span class="text_bold">نپذیرید</span> و
                    می‌خواهید فایل به همان حالت آخرین commit بازگردد:
                </p>
                <div class="code-example" dir="ltr">
                    git checkout -- &lt;file&gt;
                </div>
                <p>یا با Git نسخه جدید:</p>
                <div class="code-example" dir="ltr">
                    git restore &lt;file&gt;
                </div>
                <p>⚠ <span class="text_bold">این باعث می‌شود تمام تغییرات محلی از بین بروند</span> — بنابراین این دستور
                    را فقط وقتی استفاده کنید که مطمئن هستید نمی‌خواهید تغییراتتان حفظ شوند.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> برگرداندن (undo) commit  </h2>
            </header>

            <section class="about-text">
                <p>
                    اگر می‌خواهید <span class="text_bold">commit آخر را لغو کنید</span> و تغییرات را به حالت قبل
                    بازگردانید، می‌توانید از دستور:
                </p>
                <div class="code-example" dir="ltr">
                    git reset --soft HEAD^
                </div>
                <p>یا اگر می‌خواهید <span class="text_bold">commit + stage + تغییرات محلی را هم حذف کنید</span>:</p>
                <div class="code-example" dir="ltr">
                    git reset --hard HEAD^
                </div>
                <p><span class="text_bold">توضیح:</span></p>
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">--soft</span>: فقط <span class="text_bold">HEAD</span> (شاخه) را جابجا
                        می‌کند، <span class="text_bold">تغییرات در staging و working directory باقی می‌ماند</span>.
                    </li>
                    <li><span class="text_bold">--mixed</span> (پیش‌فرض بدون گزینه): <span class="text_bold">staging پاک می‌شود</span>،
                        ولی تغییرات در working directory می‌ماند.
                    </li>
                    <li><span class="text_bold">--hard</span>: <span class="text_bold">همه چیز</span> — staging و
                        working directory — به حالت آخرین commit باز می‌گردد.
                    </li>
                </ul>
                <p>⚠ <span class="text_bold">مواظب باشید: --hard ممکن است باعث از دست رفتن دائمی تغییرات شود</span> (مگر
                    قبلاً commit شده باشند). </p>
            </section>

            <header>
                <h2 class="h2 article-title"> بازگشت تغییرات با commit جدید: <span class="text_bold">git revert</span>
                </h2>
            </header>

            <section class="about-text">
                <p>
                    اگر commitی در گذشته دارید که می‌خواهید تغییرات آن را خنثی کنید — <span class="text_bold">بدون اینکه تاریخچه را بازنویسی کنید</span>
                    — از:
                </p>
                <div class="code-example" dir="ltr">
                    git revert &lt;commit-hash&gt;
                </div>
                <p>استفاده کنید. این دستور <span class="text_bold">یک commit جدید می‌سازد</span> که تغییرات commit
                    انتخابی را معکوس می‌کند — <span class="text_bold">تاریخچه محفوظ می‌ماند</span> و کار تیمی مختل
                    نمی‌شود.</p>
            </section>

            <header>
                <h2 class="h2 article-title">⚠ نکات مهم درباره Undo در Git</h2>
            </header>

            <section class="about-text">
                <p>
                <ul style="margin-right: 25px">
                    <li>بعضی Undoها (مثل <span class="text_bold">reset --hard</span> یا <span
                            class="text_bold">checkout</span>) <span
                            class="text_bold">تغییرات محلی را حذف می‌کنند</span> — پس فقط وقتی استفاده کن که مطمئنی.
                    </li>
                    <li>اگر commit‌ها را <span class="text_bold">push کرده‌ای</span>، بازنویسی آن‌ها (مثل <span
                            class="text_bold">--amend</span> یا <span class="text_bold">reset + force push</span>)
                        می‌تواند برای همکاران مشکل ایجاد کند.
                    </li>
                    <li>برای لغو «stage» یا برگشت به حالت قبل، <span class="text_bold">git reset</span> یا <span
                            class="text_bold">git restore</span> <span class="text_bold">امن‌تر</span> است نسبت به
                        بازنویسی تاریخچه.
                    </li>
                </ul>
                </p>
            </section>

            <header>
                <h2 id="titr-1.5" class="h2 article-title">فصل ۱.۵ — کار کردن با ریموت‌ها (<span class="text_bold">Working with Remotes</span>)
                </h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی یک پروژه با Git دارید و می‌خواهید آن را <span
                        class="text_bold">با دیگران به اشتراک بگذارید</span> یا روی پروژه‌ای که دیگران شروع کرده‌اند کار
                    کنید، باید بدانید چگونه با <span
                        class="text_bold">مخزن(های) راه‌دور (remote repository / remotes)</span> کار کنید. ریموت یعنی
                    نسخه‌ای از پروژه که <span class="text_bold">روی اینترنت یا شبکه</span> — یا حتی روی یک مکان دیگر روی
                    همان کامپیوتر — میزبانی می‌شود.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> مشاهده ریموت‌های تعریف‌شده</h2>
            </header>

            <section class="about-text">
                <p>برای دیدن <span class="text_bold">لیستی از ریموت‌ها</span> که فعلاً تنظیم کرده‌اید:</p>
                <div class="code-example" dir="ltr">
                    git remote
                </div>
                <p>برای دیدن <span class="text_bold">URL</span> مربوط به هر ریموت:</p>
                <div class="code-example" dir="ltr">
                    git remote -v
                </div>
                <p>اگر پروژه را با <span class="text_bold">git clone</span> دریافت کرده باشید، معمولاً یک ریموت با نام
                    پیش‌فرض <span class="text_bold">origin</span> دارد.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> اضافه کردن یک ریموت جدید</h2>
            </header>

            <section class="about-text">
                <p>اگر خواستید ریموت جدیدی به پروژه اضافه کنید — مثلاً مخزن گروهی یا ریموتی دیگر — از دستور زیر استفاده
                    کنید:</p>
                <div class="code-example" dir="ltr">
                    git remote add &lt;shortname&gt; &lt;url&gt;
                </div>
                <p>مثال:</p>
                <div class="code-example" dir="ltr">
                    git remote add upstream https://github.com/username/project.git
                </div>
                <p>بعد از این می‌توانید با نام کوتاه (<span class="text_bold">upstream</span>) به جای URL کامل کار کنید.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> دریافت تغییرات از ریموت — <span class="text_bold">fetch و pull</span>
                </h2>
            </header>

            <section class="about-text">
                <p>اگر می‌خواهید <span class="text_bold">آخرین تغییرات از پروژه راه‌دور</span> را بگیرید:</p>
                <div class="code-example" dir="ltr">
                    git fetch &lt;remote&gt;
                </div>
                <p>این دستور تمام داده‌هایی که محلی ندارید دانلود می‌کند، اما <span class="text_bold">تغییری در شاخه فعلی شما ایجاد نمی‌کند</span>.
                </p>
                <p>اگر شاخه محلی شما طوری تنظیم شده است که ردیاب شاخه ریموت باشد، می‌توانید:</p>
                <div class="code-example" dir="ltr">
                    git pull
                </div>
                <p>که معادل "<span class="text_bold">فچ + ادغام (merge)</span>" است؛ یعنی تغییرات ریموت دانلود و <span
                        class="text_bold">در شاخه فعلی ادغام می‌شود</span>.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> ارسال تغییرات به ریموت — <span class="text_bold">push</span></h2>
            </header>

            <section class="about-text">
                <p>وقتی آماده شدید که تغییراتی که دادید را <span class="text_bold">روی ریموت قرار دهید</span>:</p>
                <div class="code-example" dir="ltr">
                    git push &lt;remote&gt; &lt;branch&gt;
                </div>
                <p>مثلاً:</p>
                <div class="code-example" dir="ltr">
                    git push origin master
                </div>
                <p>دقت داشته باشید که اگر از مخزن اصلی clone کرده‌اید و اجازه نوشتن دارید و بین زمانی که آخرین pull زدید
                    و الآن کسی تغییر نکرده باشد، push موفق خواهد بود. در غیر این صورت، <span class="text_bold">ابتدا باید تغییرات ریموت را fetch / pull کنید، سپس push</span>.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> مدیریت ریموت‌ها (<span class="text_bold">تغییر نام یا حذف</span>)</h2>
            </header>

            <section class="about-text">
                <p>برای <span class="text_bold">تغییر نام کوتاه ریموت</span>:</p>
                <div class="code-example" dir="ltr">
                    git remote rename &lt;old-name&gt; &lt;new-name&gt;
                </div>
                <p>مثلاً:</p>
                <div class="code-example" dir="ltr">
                    git remote rename pb origin
                </div>
                <p>برای <span class="text_bold">حذف یک ریموت</span>:</p>
                <div class="code-example" dir="ltr">
                    git remote remove &lt;name&gt;
                </div>
                <p>یا</p>
                <div class="code-example" dir="ltr">
                    git remote rm &lt;name&gt;
                </div>
                <p>با این کار ریموت و تمام شاخه‌های ریموت‌-ردیابی‌شده (<span
                        class="text_bold">remote-tracking branches</span>) مرتبط با آن پاک می‌شوند.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> یادداشت مهم درباره «ریموت»</h2>
            </header>

            <section class="about-text">
                <p>ممکن است «<span class="text_bold">remote repository</span>» واقعاً روی <span class="text_bold">همان کامپیوتر شما</span>
                    باشد — یعنی <span class="text_bold">remote لزوماً به معنی «دور» یا روی اینترنت نیست</span>؛ فقط یعنی
                    «جای دیگر» نسبت به مخزن محلی.</p>
                <p>بنابراین حتی اگر repo روی همان سیستم است، همان عملیات <span class="text_bold">فچ / پول / پوش</span>
                    برای هم کار می‌کنند.</p>
            </section>

            <header>
                <h2 id="titr-1.6" class="h2 article-title">جمع‌بندی فصل
                </h2>
            </header>

            <section class="about-text">
                <p>
                    در فصل ۲ با <span class="text_bold">هسته‌ی اصلی استفاده‌ی روزمره از Git</span> آشنا شدیم؛ یعنی همان
                    مسیر همیشگی توسعه که افراد در پروژه‌های واقعی طی می‌کنند: <span class="text_bold">ایجاد مخزن، اعمال تغییرات، ثبت آن‌ها و در نهایت اشتراک و همگام‌سازی با دیگران</span>.
                    در این فصل شما یاد گرفتید که چگونه یک پروژه را وارد Git کنید، تغییرات خود را مرحله‌بندی و commit
                    نمایید، تاریخچه‌ی کار خود را بررسی کنید، اشتباهات را برگردانید و در نهایت پروژه را به مخازن راه‌دور
                    متصل کرده و با سایر هم‌تیمی‌ها همکاری کنید.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> مفاهیم کلیدی که یاد گرفتیم:</h2>
            </header>

            <section class="about-text">
                <p><span class="text_bold">1.1 گرفتن یک مخزن گیت (Getting a Git Repository)</span></p>
                <p>آموختید چگونه یک پروژه جدید را با <span class="text_bold">git init</span> گیت‌دار کنید یا پروژه‌ای
                    موجود را با <span class="text_bold">git clone</span> دریافت کنید. این دو ورودی اصلی برای شروع کار با
                    هر مخزنی در Git هستند.</p>

                <p><span class="text_bold">1.2 ثبت تغییرات در مخزن (Recording Changes to the Repository)</span></p>
                <p>یاد گرفتید که Git چگونه با فایل‌ها رفتار می‌کند و آن‌ها را در وضعیت‌های مختلف قرار می‌دهد (<span
                        class="text_bold">Untracked، Modified، Staged</span>). فرآیند افزودن و ثبت تغییرات با <span
                        class="text_bold">git add</span> و <span class="text_bold">git commit</span> کلید اصلی مدیریت
                    نسخه است.</p>

                <p><span class="text_bold">1.3 مشاهده تاریخچه کامیت‌ها (Viewing the Commit History)</span></p>
                <p>با استفاده از دستورات <span class="text_bold">git log</span> و گزینه‌های مختلف آن، نحوه‌ی بررسی
                    تاریخچه و دنبال‌کردن روند توسعه پروژه را یاد گرفتید. این بخش برای <span class="text_bold">تحلیل تغییرات گذشته</span>
                    و <span class="text_bold">دیباگ</span> بسیار مهم است.</p>

                <p><span class="text_bold">1.4 بازگرداندن تغییرات (Undoing Things)</span></p>
                <p>روش‌هایی برای <span class="text_bold">برگشت از خطاها</span> یا برگرداندن پروژه به حالت‌های قبلی یاد
                    گرفتید. ابزارهایی مانند <span class="text_bold">git restore، git reset، git checkout</span> به شما
                    امکان مدیریت اشتباهات و کنترل دقیق نسخه‌ها را می‌دهند.</p>

                <p><span class="text_bold">1.5 کار کردن با ریموت‌ها (Working with Remotes)</span></p>
                <p>با مفهوم <span class="text_bold">Remote Repository</span> آشنا شدید؛ یعنی مخزنی روی شبکه یا اینترنت
                    که امکان <span class="text_bold">همکاری بین افراد</span> را ایجاد می‌کند. دستورات <span
                            class="text_bold">git remote, git fetch, git pull, git push</span> پایه‌ی ارتباط میان مخزن
                    محلی و سرور هستند.</p>
            </section>

            <header>
                <h2 class="h2 article-title">نتیجه نهایی</h2>
            </header>

            <section class="about-text">
                <p>حال شما می‌دانید چگونه:</p>
                <ul style="margin-right: 25px">
                    <li>✔ پروژه‌ای را <span class="text_bold">وارد Git کنید</span></li>
                    <li>✔ فایل‌ها را <span class="text_bold">نسخه‌بندی و تغییرات را commit</span> نمایید</li>
                    <li>✔ <span class="text_bold">تاریخچه توسعه را ببینید و تحلیل کنید</span></li>
                    <li>✔ <span class="text_bold">تغییرات اشتباه را برگردانید</span></li>
                    <li>✔ پروژه را به <span class="text_bold">مخزن‌های ریموت متصل کنید</span> و با دیگران همکاری داشته
                        باشید
                    </li>
                </ul>
                <p>فصل ۲، <span class="text_bold">ستون اصلی کار با Git</span> است؛ مسلط‌شدن بر همین دستورات، شما را برای
                    ورود به محیط‌های تیمی و شرکت‌ها آماده می‌کند.</p>
                <p>در فصل بعدی سراغ <span class="text_bold">Branching & Merging</span> می‌رویم — مفهومی که Git را از
                    بقیه ابزارها متمایز می‌کند و <span class="text_bold">هسته‌ی توسعه‌ی گروهی</span> است.</p>
            </section>
        </article>

        <article class="portfolio " data-page="فصل ۲">
            <h2 class="h2 article-title">فصل ۲: انشعاب‌گیری در گیت</h2>

            <ul class="article-list code-example" style="margin-bottom: 24px">
                <li><span>فهرست مطالب فصل</span></li>
                <li><a href="#titr-2.1"> ۲.۱ - شاخه‌ها در یک نگاه</a></li>
                <li><a href="#titr-2.2"> ۲.۲ - شاخه‌بندی و ادغام پایه‌ای</a></li>
                <li><a href="#titr-2.3"> ۲.۳ - مدیریت شاخه‌ها در Git</a></li>
                <li><a href="#titr-2.4"> ۲.۴ - روندهای کاری شاخه‌ها</a></li>
                <li><a href="#titr-2.5"> ۲.۵ - بازپایه‌گذاری در Git</a></li>
                <li><a href="#titr-2.6">۲.۶ – جمع‌بندی فصل</a></li>
            </ul>

            <header>
                <h2 id="titr-2.1" class="h2 article-title">فصل ۲.۱ — شاخه‌ها در یک نگاه (<span class="text_bold">Branches in a Nutshell</span>)</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی با پروژه‌های نرم‌افزاری کار می‌کنیم، معمولاً لازم است همزمان <span class="text_bold">چند قابلیت، باگ فیکس یا آزمایش</span> روی ایده‌های مختلف انجام دهیم — اما نخواهیم که این تغییرات همه همزمان و در کد اصلی وارد شوند. اینجاست که <span class="text_bold">شاخه (branch)</span> وارد عمل می‌شود.
                </p>
                <p>
                    <span class="text_bold">نکته مهم: در Git، شاخه‌ها بسیار سبک و سریع هستند</span> — بر خلاف بسیاری از سیستم‌های کنترل نسخه که شاخه‌بندی هزینه‌بر است. Git اجازه می‌دهد چندین بار در روز شاخه بسازید، بین آن‌ها جابجا شوید و تغییرات جداگانه انجام دهید، <span class="text_bold">بی‌آنکه بر شاخه اصلی تأثیر بگذارید</span>.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> مفهوم شاخه در Git</h2>
            </header>

            <section class="about-text">
                <p>
                    Git داده‌ها را به صورت سری از <span class="text_bold">snapshot (تصاویر لحظه‌ای)</span> ذخیره می‌کند، نه به صورت لیستی از تغییرات.
                </p>
                <p>
                    هر <span class="text_bold">commit</span> در Git یک شیء است که به آن snapshot اختصاص دارد؛ <span class="text_bold">شاخه</span> در واقع یک "<span class="text_bold">اشاره‌گر سبک</span>" به یکی از این commitهاست.
                </p>
                <p>
                    شاخه <span class="text_bold">پیش‌فرض</span> پس از git init معمولاً با نام <span class="text_bold">master</span> (یا اخیراً <span class="text_bold">main</span>) ساخته می‌شود. اما این شاخه ویژه نیست — مثل هر شاخه دیگر است.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> ساخت و جابجایی شاخه</h2>
            </header>

            <section class="about-text">
                <p>برای <span class="text_bold">ساخت شاخه جدید</span>:</p>
                <div class="code-example" dir="ltr">
                    git branch &lt;branch-name&gt;
                </div>
                <p>این دستور فقط <span class="text_bold">اشاره‌گر جدیدی به همان commit فعلی</span> ایجاد می‌کند؛ تا زمانی که روی شاخه بروید (checkout / switch)، کاری نمی‌کند.</p>

                <p>برای <span class="text_bold">تغییر شاخه</span> (جابجایی HEAD به شاخه دیگر):</p>
                <div class="code-example" dir="ltr">
                    git checkout &lt;branch-name&gt;
                </div>
                <p>یا در Git‌های جدیدتر:</p>
                <div class="code-example" dir="ltr">
                    git switch &lt;branch-name&gt;
                </div>

                <p>اگر بخواهید <span class="text_bold">شاخه بسازید و همزمان به آن سوئیچ کنید</span>:</p>
                <div class="code-example" dir="ltr">
                    git checkout -b &lt;branch-name&gt;
                </div>
                <p>یا:</p>
                <div class="code-example" dir="ltr">
                    git switch -c &lt;branch-name&gt;
                </div>
            </section>

            <header>
                <h2 class="h2 article-title"> کارکرد شاخه‌ها — <span class="text_bold">تغییرات جداگانه و ایزوله</span></h2>
            </header>

            <section class="about-text">
                <p>
                    فرض کنید شاخه <span class="text_bold">master</span> دارید و می‌خواهید ویژگی جدیدی توسعه دهید. به جای تغییر مستقیم در master:
                </p>
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">شاخه جدیدی</span> (مثلاً feature/new-ui) ایجاد می‌کنید</li>
                    <li><span class="text_bold">روی آن شاخه کار می‌کنید</span> (اضافه کردن فایل، ویرایش، commit)</li>
                    <li>meanwhile شاخه اصلی (master) <span class="text_bold">ثابت می‌ماند</span> و اگر نیاز شد، می‌توانید روی آن تغییر دیگر انجام دهید</li>
                </ul>
                <p>نتیجه: تغییرات feature جدید <span class="text_bold">کاملاً ایزوله‌اند</span> و تداخلی با کد پایدار ندارند. </p>
                <p>با این روش، تیم می‌تواند <span class="text_bold">همزمان روی چند قابلیت یا باگ کار کند</span> بدون اینکه تغییرات نهایی با هم قاطی شوند.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> مزایای استفاده از شاخه‌ها</h2>
            </header>

            <section class="about-text">
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">توسعه موازی و همکاری تیمی</span>: هر ویژگی یا باگ در شاخه جداگانه، بدون اثر بر شاخه اصلی</li>
                    <li><span class="text_bold">ایزوله بودن تغییرات</span>: امکان آزمایش یا تغییر بزرگ بدون خطر خراب شدن کد پایدار</li>
                    <li><span class="text_bold">حفظ تاریخچه تمیز و قابل فهم</span>: تغییرات هر شاخه مستقل از بقیه است؛ بعد از merge تاریخچه واضح می‌ماند</li>
                    <li><span class="text_bold">انعطاف و سرعت بالا</span>: ایجاد و جابجایی شاخه‌ها در Git خیلی سریع هستند، بدون نیاز به کپی کامل پروژه</li>
                </ul>
            </section>

            <header>
                <h2 class="h2 article-title"> مثال ساده کار با شاخه‌ها</h2>
            </header>

            <section class="about-text">
                <p>فرض کنید پروژه را تازه کلون کردید و روی شاخه پیش‌فرض (<span class="text_bold">master</span>) هستید:</p>
                <div class="code-example" dir="ltr">
                    git checkout -b feature/login-page   # شاخه feature/login-page بساز و برو روی آن<br>
                    # فایل‌های لازم را اضافه یا ویرایش کن<br>
                    git add .<br>
                    git commit -m "Add login page UI"
                </div>
                <p>همزمان اگر بخواهید تغییرات دیگری مثل بهبود طراحی در شاخه اصلی انجام دهید:</p>
                <div class="code-example" dir="ltr">
                    git checkout master<br>
                    # تغییرات دیگر<br>
                    git commit -m "Update README and documentation"
                </div>
                <p>حالا هم شاخه master بروز است و هم feature/login-page، <span class="text_bold">بدون تداخل</span>. وقتی ویژگی آماده شد، می‌توان آن را merge کرد.</p>
            </section>

            <header>
                <h2 id="titr-2.2" class="h2 article-title">فصل ۲.۲ — شاخه‌بندی و ادغام پایه‌ای (<span class="text_bold">Basic Branching and Merging</span>)</h2>
            </header>

            <section class="about-text">
                <p>
                    در این بخش با نحوه <span class="text_bold">ساخت شاخه (branch)</span>، <span class="text_bold">کار مستقل</span> روی شاخه‌های مختلف، و سپس <span class="text_bold">ادغام آن‌ها (merge)</span> آشنا می‌شویم. این قابلیت، یکی از <span class="text_bold">قدرتمندترین ویژگی‌های Git</span> است که فرآیند توسعه، آزمایش و انتشار را برای تیم‌ها و پروژه‌ها بسیار انعطاف‌پذیر می‌کند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> ساخت شاخه و کار روی آن (<span class="text_bold">Branching</span>)</h2>
            </header>

            <section class="about-text">
                <p>برای ساخت شاخه جدید و <span class="text_bold">همزمان جابجایی (checkout)</span> به آن:</p>
                <div class="code-example" dir="ltr">
                    git checkout -b &lt;branch-name&gt;
                </div>
                <p>این معادل اجرای دو دستور <span class="text_bold">git branch &lt;branch-name&gt;</span> و سپس <span class="text_bold">git checkout &lt;branch-name&gt;</span> است.</p>
                <p>پس از تغییر شاخه، <span class="text_bold">HEAD به آن شاخه جدید اشاره می‌کند</span> و هر commit‌ای که بزنی روی آن شاخه ثبت می‌شود — <span class="text_bold">بدون دخالت در شاخه اصلی</span> (مثلاً master).</p>
                <p>اگر شاخه قبلی تغییراتی داشته و commit نشده باشند، قبل از سوئیچ شاخه باید <span class="text_bold">پوشه کاری (working directory) تمیز باشد</span>؛ در غیر این صورت Git اجازه نمی‌دهد شاخه عوض شود.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> ادغام شاخه‌ها (<span class="text_bold">Merging</span>)</h2>
            </header>

            <section class="about-text">
                <p>وقتی شاخه‌ای (مثلاً برای یک ویژگی یا اصلاح خاص) <span class="text_bold">تکمیل شد</span>، معمول است آن را وارد شاخه اصلی (مثل master) کنیم:</p>
                <p>ابتدا بر روی <span class="text_bold">شاخه هدف</span> (مثلاً master) بروید:</p>
                <div class="code-example" dir="ltr">
                    git checkout master
                </div>
                <p>سپس شاخه مورد نظر را ادغام کنید:</p>
                <div class="code-example" dir="ltr">
                    git merge &lt;branch-name&gt;
                </div>


                <p><span class="text_bold">دو حالت ادغام:</span></p>
                <p><span class="text_bold">Fast-Forward Merge</span></p>
                <p>اگر شاخهٔ هدف تغییری نداشته باشد و شاخه فرعی دقیقاً <span class="text_bold">ادامه‌ی همان تاریخچه</span> باشد، Git تنها <span class="text_bold">اشاره‌گر شاخه را جلو می‌برد</span> — بدون ساخت commit جدید. </p>

                <p><span class="text_bold">Three-way Merge (ادغام سه طرفه)</span></p>
                <p>اگر دو شاخه <span class="text_bold">از هم منشعب شده باشند</span> (فعالیت مستقل)، Git <span class="text_bold">سه‌طرفه ادغام می‌کند</span>: snapshot شاخه هدف + snapshot شاخه فرعی + نقطه مشترک قبلی. نتیجه یک <span class="text_bold">merge commit جدید</span> با بیش از یک والد است. </p>
            </section>

            <header>
                <h2 class="h2 article-title">⚠ تعارض ادغام (<span class="text_bold">Merge Conflict</span>)</h2>
            </header>

            <section class="about-text">
                <p>اگر در شاخه‌ها، <span class="text_bold">تغییرات متفاوتی روی همان بخش از یک فایل</span> انجام شده باشد، Git <span class="text_bold">نمی‌تواند ادغام خودکار انجام دهد</span>. در این حالت:</p>
                <ul style="margin-right: 25px">
                    <li>Git فرآیند merge را متوقف می‌کند و فایل(ها) را با <span class="text_bold">نشانه‎‌گذاری تعارض (conflict markers)</span> علامت می‌زند.</li>
                    <li>با <span class="text_bold">git status</span> می‌توانید بفهمید کدام فایل‌ها نیاز به بررسی دارند.</li>
                    <li>پس از باز کردن و <span class="text_bold">اصلاح تعارض</span>، فایل(ها) را <span class="text_bold">git add</span> کنید تا حل آن به Git اطلاع داده شود.</li>
                    <li>در نهایت با <span class="text_bold">git commit</span> ادغام را کامل کنید.</li>
                </ul>
                <p>همچنین می‌توانید از ابزارهای گرافیکی یا ادیتورهایی با <span class="text_bold">ادغام تصویری (merge tools)</span> استفاده کنید (مثل git mergetool) تا کار راحت‌تر شود.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> پاک‌کردن شاخه پس از ادغام</h2>
            </header>

            <section class="about-text">
                <p>اگر پس از merge دیگر به شاخه فرعی نیازی ندارید، می‌توانید آن را <span class="text_bold">حذف کنید</span>:</p>
                <div class="code-example" dir="ltr">
                    git branch -d &lt;branch-name&gt;
                </div>
                <p>تا لیست شاخه‌ها <span class="text_bold">تمیز بماند</span> و گیج‌کننده نباشد.</p>
            </section>

            <header>
                <h2 id="titr-2.3" class="h2 article-title">فصل ۲.۳ — مدیریت شاخه‌ها (<span class="text_bold">Branch Management</span>) در Git</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی پروژه با <span class="text_bold">شاخه (branch) زیاد</span> کار می‌کند — شاخه‌های ویژگی، شاخه‌های اصلاح باگ، شاخه‌های موقت و ... — <span class="text_bold">مدیریت شاخه‌ها اهمیت زیادی پیدا می‌کند</span>. Git ابزارهایی دارد که کار با شاخه‌ها را ساده کرده و به شما کمک می‌کند پروژه‌تان منظم بماند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> مشاهده شاخه‌های موجود</h2>
            </header>

            <section class="about-text">
                <p>اجرای ساده:</p>
                <div class="code-example" dir="ltr">
                    git branch
                </div>
                <p>بدون آرگومان، <span class="text_bold">فهرستی از شاخه‌های محلی</span> پروژه نمایش می‌دهد. شاخه‌ای که در حال حاضر فعال است، با علامت <span class="text_bold">*</span> نشان داده می‌شود.</p>
                <p>مثال:</p>
                <div class="code-example" dir="ltr">
                    iss53<br>
                    * master<br>
                    testing
                </div>
                <p>برای دیدن <span class="text_bold">آخرین commit هر شاخه</span>:</p>
                <div class="code-example" dir="ltr">
                    git branch -v
                </div>
                <p>خروجی شامل شناسه commit و پیام کوتاه آن برای هر شاخه است.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> فیلتر شاخه‌ها با وضعیت ادغام — <span class="text_bold">--merged و --no-merged</span></h2>
            </header>

            <section class="about-text">
                <p>برای دیدن شاخه‌هایی که <span class="text_bold">قبلاً به شاخه فعلی مرج (merge) شده‌اند</span>:</p>
                <div class="code-example" dir="ltr">
                    git branch --merged
                </div>
                <p>برای مثال اگر قبلاً شاخه iss53 را merge کرده باشید، فهرست نشان می‌دهد. شاخه‌هایی که بدون * هستند (یعنی شاخه فعلی نیستند) معمولاً <span class="text_bold">ایمن هستند برای حذف</span>.</p>

                <p>برای دیدن شاخه‌هایی که <span class="text_bold">هنوز merge نشده‌اند</span>:</p>
                <div class="code-example" dir="ltr">
                    git branch --no-merged
                </div>
                <p>اگر شاخه‌ای تغییراتی دارد که merge نشده اند، در این فهرست قرار می‌گیرد. <span class="text_bold">حذف آن با دستور حذف معمولی (git branch -d) شکست می‌خورد و هشدار می‌دهد</span>.</p>

                <p>اگر بخواهید <span class="text_bold">اجباری حذف</span> انجام دهید (با از دست رفتن تاریخچه شاخه)، می‌توانید:</p>
                <div class="code-example" dir="ltr">
                    git branch -D &lt;branch-name&gt;
                </div>
                <p>⚠ استفاده از <span class="text_bold">-D</span> یعنی شما متعهد می‌شوید که دیگر به شاخه نیازی ندارید.</p>
            </section>

            <header>
                <h2 class="h2 article-title"> تغییر نام شاخه (<span class="text_bold">Rename Branch</span>)</h2>
            </header>

            <section class="about-text">
                <p>گاهی لازم است نام شاخه‌ای مناسب‌تر شود — برای مرتب کردن شاخه‌ها یا هماهنگی با سیاست پروژه. برای <span class="text_bold">تغییر نام محلی شاخه</span>:</p>
                <div class="code-example" dir="ltr">
                    git branch --move &lt;old-name&gt; &lt;new-name&gt;
                </div>
                <p>مثلاً:</p>
                <div class="code-example" dir="ltr">
                    git branch --move bad-branch-name corrected-branch-name
                </div>
                <p>این تغییر <span class="text_bold">محلی</span> انجام می‌شود و تاریخچه حفظ می‌گردد.</p>

                <p>اگر شاخه را روی <span class="text_bold">ریموت</span> هم دارید و می‌خواهید نام جدید روی ریموت نیز ثبت شود:</p>
                <p>شاخه جدید را با push بفرستید و upstream آن را تنظیم کنید:</p>
                <div class="code-example" dir="ltr">
                    git push --set-upstream origin corrected-branch-name
                </div>
                <p>سپس شاخه قدیمی را از ریموت حذف کنید:</p>
                <div class="code-example" dir="ltr">
                    git push origin --delete bad-branch-name
                </div>
                <p>با این ترتیب، <span class="text_bold">تغییر نام کامل (محلی + ریموت)</span> انجام می‌شود.</p>
            </section>

            <header>
                <h2 class="h2 article-title">⚠ نکته درباره تغییر نام شاخه اصلی (مثل <span class="text_bold">master → main</span>)</h2>
            </header>

            <section class="about-text">
                <p>
                    تغییر نام شاخه اصلی پروژه (مثلاً از master به main یا هر نام دیگر) <span class="text_bold">کار حساسی است</span>. اگر مخزن روی ریموت است یا همکارانی دارید، باید اطمینان حاصل کنید:
                </p>
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">تمام ارجاعات به نام قدیمی شاخه</span> (در اسکریپت‌ها، تنظیمات CI/CD، مستندات و …) اصلاح شود.</li>
                    <li><span class="text_bold">شاخه جدید را به ریموت بفرستید (push) و شاخه قدیمی را حذف کنید</span> (push … --delete) پس از اطمینان از همگام‌سازی.</li>
                    <li>اگر همکاری تیمی دارید، <span class="text_bold">هماهنگی کامل با تیم</span> انجام دهید تا کسی با شاخه قدیمی کار نکند.</li>
                </ul>
            </section>

            <header>
                <h2 id="titr-2.4" class="h2 article-title">فصل ۲.۴ — روندهای کاری شاخه‌ها (<span class="text_bold">Branching Workflows</span>)</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی اصول پایه‌ای شاخه‌بندی و ادغام (branch + merge) در Git رو یاد گرفتید، سؤال بعدی این است: «الان به چه شکلی پروژه را اداره کنیم؟» یعنی <span class="text_bold">ساختار شاخه‌ها و فرآیند همکاری تیمی</span> روی شاخه‌ها چطور باشد. این فصل چند مدل رایج را معرفی می‌کند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> مدل شاخه‌های بلندمدت (<span class="text_bold">Long-Running Branches</span>)</h2>
            </header>

            <section class="about-text">
                <p>
                    در این مدل شما چند شاخه دارید که <span class="text_bold">همه‌وقت بازند</span> و مانند «خط توسعه» یا «خط پایدار» کار می‌کنند. مثلاً <span class="text_bold">شاخه اصلی (master یا main)</span> شاخه‌ای است که فقط شامل <span class="text_bold">کد پایدار و آماده انتشار</span> است. شاخه دیگر (مثلاً develop, next, یا stable) شاخه‌ای است برای <span class="text_bold">کار روزمره، تغییرات در حال توسعه، آزمایش و تست</span>.
                </p>
                <p>
                    ویژگی این مدل: می‌توانید به‌طور مرتب از شاخه توسعه کد تغییر یافته را به شاخه پایدار merge کنید، بدون اینکه شاخه توسعه تعطیل شود — یعنی پروژه قابلیت <span class="text_bold">توسعه پیوسته و انتشار منظم</span> را دارد.
                </p>
                <p>
                    این مدل برای پروژه‌هایی مفید است که <span class="text_bold">چرخه انتشار (release)</span> دارند، یا وقتی نیاز دارید بین کد پایدار و کد در حال توسعه تفکیک داشته باشید.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> شاخه‌های موقت برای ویژگی‌ها / اصلاحات (<span class="text_bold">Topic / Feature Branches</span>)</h2>
            </header>

            <section class="about-text">
                <p>
                    هر زمانی که می‌خواهید ویژگی جدیدی اضافه کنید، باگی رفع کنید یا تغییر خاصی انجام دهید — <span class="text_bold">یک شاخه جدا ایجاد می‌کنید</span> (branch) و روی آن کار می‌کنید. این شاخه می‌تواند کوتاه‌مدت باشد، فقط مخصوص همان تغییر. سپس پس از تکمیل، آن را با شاخه اصلی یا شاخه توسعه merge می‌کنید و <span class="text_bold">شاخه موقت را حذف می‌کنید</span>.
                </p>
                <p>
                    این مدل مزایا دارد: <span class="text_bold">تغییرات ایزوله می‌شوند</span>، شاخه اصلی سالم می‌ماند، و اگر روی ویژگی کار می‌کنید — تاثیری روی بقیه کد ندارد تا وقتی ویژگی کامل و پایدار شود.
                </p>
                <p>
                    معمولاً هر فیچر / باگ / وظیفه جدید — شاخه جدا؛ بعد از merge → شاخه حذف شود. این کار <span class="text_bold">مرتب بودن مخزن و تاریخچه</span> را تضمین می‌کند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> مدل ترکیبی / سلسله‌مراتبی (Integration / Release / Hotfix Branches) — مثل <span class="text_bold">Gitflow</span></h2>
            </header>

            <section class="about-text">
                <p>
                    در پروژه‌های پیچیده یا تیمی با چرخه توسعه/ انتشار دقیق، از یک مدل شاخه‌بندی با <span class="text_bold">چند شاخه «وظیفه‌ای» و «نقشی»</span> استفاده می‌شود:
                </p>
                <ul style="margin-right: 25px">
                    <li>شاخه‌ای برای <span class="text_bold">توسعه عمومی</span> (develop / next)</li>
                    <li>شاخه‌هایی برای <span class="text_bold">ویژگی‌ها</span> (feature)</li>
                    <li>شاخه‌هایی برای <span class="text_bold">آماده‌سازی انتشار</span> (release)</li>
                    <li>شاخه‌هایی برای <span class="text_bold">رفع سریع باگ یا هات‌فیکس</span> (hotfix)</li>
                </ul>
                <p>
                    <span class="text_bold">هر شاخه نقش مشخصی دارد</span> و ترکیب آن‌ها طبق سیاست پروژه است: فیچرها روی شاخه feature توسعه داده می‌شوند؛ پس از تست روی develop یا تستِ release؛ و در نهایت به شاخه اصلی merge می‌شوند. این مدل <span class="text_bold">ساختار و نظم خوبی</span> به پروژه می‌دهد.
                </p>
                <p>
                    با این مدل می‌توان به راحتی <span class="text_bold">کنترل کیفیت، مرحله تست، آماده‌سازی برای انتشار و مدیریت هات‌فیکس‌ها</span> را سازمان‌دهی کرد.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> چگونه انتخاب کنیم؟ — <span class="text_bold">نکاتی برای تصمیم درباره Workflow مناسب</span></h2>
            </header>

            <section class="about-text">
                <p>بسته به <span class="text_bold">اندازه تیم، تعداد توسعه‌دهندگان، فاز پروژه و نیاز به انتشار مداوم</span>:</p>
                <table style="width:100%; border-collapse: collapse; margin: 20px 0; text-align: right;">
                    <tr style="background-color: #f5f5f5;">
                        <th style="border: 1px solid #ddd; padding: 10px;"><span class="text_bold">شرایط / هدف</span></th>
                        <th style="border: 1px solid #ddd; padding: 10px;"><span class="text_bold">مدل پیشنهادی</span></th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 10px;">پروژه کوچک یا تک‌نفره — تغییرات ساده</td>
                        <td style="border: 1px solid #ddd; padding: 10px;"><span class="text_bold">Feature-branch + شاخه اصلی پایدار</span></td>
                    </tr>
                    <tr style="background-color: #f9f9f9;">
                        <td style="border: 1px solid #ddd; padding: 10px;">پروژه با چند ویژگی همزمان — نیاز به آزمایش ویژگی‌ها</td>
                        <td style="border: 1px solid #ddd; padding: 10px;"><span class="text_bold">شاخه‌های موقت + شاخه توسعه + سپس merge</span></td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 10px;">پروژه بزرگ با چرخه انتشار — نیاز به نسخه پایدار، تست، هات‌فیکس</td>
                        <td style="border: 1px solid #ddd; padding: 10px;"><span class="text_bold">مدل چند شاخه‌ای (feature / develop / release / hotfix) مانند Gitflow</span></td>
                    </tr>
                    <tr style="background-color: #f9f9f9;">
                        <td style="border: 1px solid #ddd; padding: 10px;">تیم کوچک ولی مداوم deploy / release دارند</td>
                        <td style="border: 1px solid #ddd; padding: 10px;"><span class="text_bold">شاخه‌های بلندمدت + شاخه feature برای هر task</span></td>
                    </tr>
                </table>
            </section>

            <header>
                <h2 class="h2 article-title"> نکات مهم در استفاده از Branching Workflows</h2>
            </header>

            <section class="about-text">
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">شاخه‌ها را زیاد اما منطقی بسازید</span> — Git ساخت شاخه را سبک کرده است، پس استفاده از شاخه موقت برای هر فیچر توصیه می‌شود.</li>
                    <li>هر شاخه‌ای که کارش تمام شد و merge شد — <span class="text_bold">حذفش کنید</span> تا مخزن تمیز بماند.</li>
                    <li>قبل از merge مطمئن شوید شاخه مبدا (base) <span class="text_bold">بروز باشد</span>، برای جلوگیری از conflict یا اشتباه.</li>
                    <li>برای پروژه تیمی، <span class="text_bold">فلو (workflow) را با تیم انتخاب کنید و آن را مستند نمایید</span> — نظم مهم است.</li>
                </ul>
            </section>

            <header>
                <h2 id="titr-2.5" class="h2 article-title">فصل ۲.۵ — بازپایه‌گذاری (<span class="text_bold">Rebasing</span>) در Git</h2>
            </header>

            <section class="about-text">
                <p>
                    گاهی در پروژه می‌خواهیم تغییراتی را که روی یک شاخه انجام داده‌ایم با تغییرات شاخه دیگر ترکیب کنیم — اما می‌خواهیم <span class="text_bold">تاریخچه (commit history) تمیز و خطی باقی بماند</span>. Rebasing یک روش جایگزین برای ادغام (merge) است که به همین هدف کمک می‌کند.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> بازپایه‌گذاری چیست؟</h2>
            </header>

            <section class="about-text">
                <p>
                    در حالت عادی وقتی دو شاخه جدا از هم تغییر کرده‌اند و بخواهیم آن‌ها را ادغام کنیم، از <span class="text_bold">merge</span> استفاده می‌کنیم؛ Git تاریخچه را به صورت <span class="text_bold">درختی</span> (با شاخه و شاخه) نگه می‌دارد.
                </p>
                <p>
                    با بازپایه‌گذاری (<span class="text_bold">rebase</span>) به جای ادغام نهایی، Git تغییراتی که در شاخه فعلی داده شده‌اند را برداشته، و مثل «پچ» (patch) روی شاخه مقصد «<span class="text_bold">دوباره اعمال</span>» می‌کند. نتیجه: شاخه فعلی انگار از نو بر پایه شاخه مقصد ساخته شده — یعنی <span class="text_bold">تاریخچه‌ای خطی (linear history)</span>.
                </p>
                <p>
                    به عبارتی: rebase مثل این است که «می‌گوییم کارمان را تازه شروع کرده‌ایم روی <span class="text_bold">جدیدترین نسخه شاخه مقصد</span>».
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> چگونه <span class="text_bold">rebase</span> کنیم — دستورات اصلی</h2>
            </header>

            <section class="about-text">
                <p>فرض کنید روی شاخه <span class="text_bold">feature</span> کار می‌کنید و می‌خواهید آن را روی آخرین وضعیت شاخه <span class="text_bold">master</span> بیارید:</p>
                <div class="code-example" dir="ltr">
                    git checkout feature<br>
                    git rebase master
                </div>
                <p>Git تغییرات شاخه feature را می‌گیرد و روی سر شاخه master «دوباره» اعمال می‌کند.</p>

                <p>همچنین اگر شاخه موضوعی (topic branch) دارید و می‌خواهید آن را روی شاخه‌ای دیگر <span class="text_bold">بازپایه کنید</span>:</p>
                <div class="code-example" dir="ltr">
                    git rebase --onto &lt;newBase&gt; &lt;oldBase&gt; &lt;topicBranch&gt;
                </div>
                <p>برای مثال، اگر شاخه client از server منشعب شده و می‌خواهید فقط تغییرات client را مستقیماً روی master قرار دهید:</p>
            </section>

            <header>
                <h2 class="h2 article-title"> مزایای <span class="text_bold">rebase</span> نسبت به <span class="text_bold">merge</span></h2>
            </header>

            <section class="about-text">
                <ul style="margin-right: 25px">
                    <li><span class="text_bold">تاریخچه‌ی خطی و تمیز</span> — بدون merge commit‌های متعدد و شاخه‌های درهم.</li>
                    <li>به نگهدارنده پروژه کمک می‌کند که کد دریافتی را <span class="text_bold">ساده‌تر بررسی کند</span> — مثل fast-forward merge.</li>
                    <li>مناسب برای شاخه‌های <span class="text_bold">محلی</span> یا زمانی که تغییرات هنوز منتشر (<span class="text_bold">push</span>) نشده‌اند: می‌توان قبل از push کردن، تاریخچه را مرتب کرد.</li>
                </ul>
            </section>

            <header>
                <h2 class="h2 article-title">⚠ خطرات و نکات احتیاطی</h2>
            </header>

            <section class="about-text">
                <p>
                    وقتی rebase انجام می‌دهید، در واقع commitهای اصلی شاخه را <span class="text_bold">پاک و commitهای جدیدی می‌سازید</span> — یعنی <span class="text_bold">تاریخچه تغییر می‌کند</span>. اگر آن commitها <span class="text_bold">به اشتراک رفته‌اند (push شده‌اند</span> و دیگران بر اساس آن‌ها کار کرده‌اند)، بازنویسی تاریخچه می‌تواند باعث سردرگمی، duplicate شدن commitها و مشکلات ادغام شود.
                </p>
                <p>
                    بنابراین: <span class="text_bold">هرگز commitهایی را که عمومی شده‌اند (push شده‌اند) بازپایه‌گذاری نکنید</span> (یا اگر لازم است، حتماً با <span class="text_bold">force-push + هماهنگی تیم</span> همراه باشد).
                </p>
                <p>
                    اگر مجبور به rebase روی شاخه مشترک شدید، تیم باید بداند و همه با گزینه‌هایی مثل <span class="text_bold">git pull --rebase</span> کار کنند تا تاریخچه مشترک به هم نخورد.
                </p>
            </section>

            <header>
                <h2 class="h2 article-title"> چه زمانی از <span class="text_bold">rebase</span> استفاده کنیم؟</h2>
            </header>

            <section class="about-text">
                <ul style="margin-right: 25px">
                    <li>وقتی <span class="text_bold">شاخه محلی دارید</span>، هنوز push نکرده‌اید و می‌خواهید قبل از ادغام تاریخچه مرتب باشد.</li>
                    <li>وقتی می‌خواهید commitهای <span class="text_bold">clean و کاربردی</span> (غیر آزمایشی) به پروژه اصلی بفرستید — مثلاً برای Pull Request در پروژه‌های متن‌باز.</li>
                    <li>وقتی تیم شما <span class="text_bold">سیاست واضحی برای تاریخچه</span> دارد و موافق بازنویسی commit محلی است.</li>
                </ul>
            </section>

            <header>
                <h2 id="titr-2.6" class="h2 article-title">۲.۶ – جمع‌بندی فصل</h2>
            </header>

            <section class="about-text">
                <p>
                    در این فصل با یکی از <span class="text_bold">مهم‌ترین و قدرتمندترین قابلیت‌های Git</span> یعنی انشعاب‌گیری (<span class="text_bold">Branching</span>) آشنا شدیم. شاخه‌ها به ما امکان می‌دهند <span class="text_bold">بدون ایجاد اختلال در نسخه پایدار پروژه</span>، روی ویژگی‌ها، رفع باگ‌ها یا آزمایش ایده‌های جدید کار کنیم.
                </p>
            </section>

            <section class="about-text">
                <p>
                    در ابتدا دیدیم که شاخه‌ها در Git بسیار <span class="text_bold">سبک</span> هستند و تنها یک <span class="text_bold">اشاره‌گر به آخرین commit</span> محسوب می‌شوند؛ به همین دلیل ایجاد، جابه‌جایی و حذف شاخه‌ها بسیار سریع انجام می‌شود.  سپس با مفاهیم پایه‌ای مانند <span class="text_bold">ساخت یک شاخه، انتقال به آن و ادغام تغییرات از طریق merge</span> آشنا شدیم.
                </p>
            </section>

            <section class="about-text">
                <p>
                    در بخش مدیریت شاخه‌ها یاد گرفتیم چگونه شاخه‌های موجود را مشاهده کنیم، نام شاخه‌ها را تغییر دهیم و شاخه‌های قدیمی یا بی‌استفاده را حذف کنیم. همچنین با <span class="text_bold">روندهای کاری رایج</span> مانند شاخه‌بندی ویژگی (Feature Branching)، شاخه توسعه (Develop Branch) و الگوهای معروف مثل <span class="text_bold">Git Flow</span> آشنا شدیم که هرکدام در پروژه‌های مختلف ساده تا سازمانی کاربرد دارند.
                </p>
            </section>

            <section class="about-text">
                <p>
                    در نهایت با مفهوم <span class="text_bold">بازپایه‌گذاری (Rebasing)</span> و تفاوت آن با Merge آشنا شدیم. Rebase به ما اجازه می‌دهد <span class="text_bold">تاریخچه‌ای خطی و تمیز</span> ایجاد کنیم، اما باید با احتیاط از آن استفاده شود، چون تاریخچه commitها را <span class="text_bold">بازنویسی می‌کند</span>.
                </p>
            </section>

            <section class="about-text">
                <p>
                    به طور خلاصه، این فصل اهمیت شاخه‌ها در <span class="text_bold">همکاری گروهی، مدیریت نسخه و کنترل بهتر توسعه نرم‌افزار</span> را نشان داد. با درک صحیح branching، merge و rebase می‌توانید پروژه‌های بزرگ‌تر و تیمی را <span class="text_bold">ساختارمند، قابل پیش‌بینی و حرفه‌ای‌تر</span> پیش ببرید.
                </p>
            </section>
        </article>

        <article class="blog " data-page="فصل ۳">
            <header>
                <h2 class="h2 article-title">Blog</h2>
            </header>

            <section class="blog-posts">
                <ul class="blog-posts-list">
                    <li class="blog-post-item">
                        <a href="#">
                            <figure class="blog-banner-box">
                                <img src="https://i.postimg.cc/DysCZrWs/blog-1.jpg" alt="Design conferences in 2024"
                                     loading="lazy">
                            </figure>

                            <div class="blog-content">
                                <div class="blog-meta">
                                    <p class="blog-category">Design</p>
                                    <span class="dot"></span>
                                    <time datetime="2024-02-23">Feb 23, 2024</time>
                                </div>

                                <h3 class="h3 blog-item-title">Design conferences in 2024</h3>
                                <p class="blog-text">In 2024, several exciting design conferences are set to take
                                    place, offering opportunities for professionals and enthusiasts to connect,
                                    learn, and share innovative ideas.</p>
                            </div>
                        </a>
                    </li>

                    <li class="blog-post-item">
                        <a href="#">
                            <figure class="blog-banner-box">
                                <img src="https://i.postimg.cc/QC7qFDMs/blog-2.jpg" alt="Best fonts every designer"
                                     loading="lazy">
                            </figure>


                            <div class="blog-content">
                                <div class="blog-meta">
                                    <p class="blog-category">Design</p>
                                    <span class="dot"></span>
                                    <time datetime="2024-01-29">Jan 29, 2024</time>
                                </div>

                                <h3 class="h3 blog-item-title">Best fonts every designer</h3>
                                <p class="blog-text">When it comes to typography, choosing the right font is
                                    essential for effective design. In this article, I'll bring a brief overview of
                                    some of the best fonts that every designer should consider incorporating into
                                    their toolkit.</p>
                            </div>
                        </a>
                    </li>

                    <li class="blog-post-item">
                        <a href="#">
                            <figure class="blog-banner-box">
                                <img src="https://i.postimg.cc/W1T71QcL/blog-3.jpg" alt="Design digest #80"
                                     loading="lazy">
                            </figure>

                            <div class="blog-content">
                                <div class="blog-meta">
                                    <p class="blog-category">Design</p>
                                    <span class="dot"></span>
                                    <time datetime="2023-12-20">Dec 20, 2023</time>
                                </div>

                                <h3 class="h3 blog-item-title">Design digest #80</h3>
                                <p class="blog-text">Hello, my friends. In this Design Digest, I'll show you a
                                    curated collection of the latest trends, insights, and innovations in the design
                                    world. This edition highlights key themes and discussions that are shaping the
                                    future of design.</p>
                            </div>
                        </a>
                    </li>

                    <li class="blog-post-item">
                        <a href="#">
                            <figure class="blog-banner-box">
                                <img src="https://i.postimg.cc/2S0n8yxh/blog-4.jpg" alt="2023 UI interactions"
                                     loading="lazy">
                            </figure>

                            <div class="blog-content">
                                <div class="blog-meta">
                                    <p class="blog-category">Design</p>
                                    <span class="dot"></span>
                                    <time datetime="2023-11-29">Nov 29, 2023</time>
                                </div>

                                <h3 class="h3 blog-item-title">2023 UI interactions</h3>
                                <p class="blog-text">As we move into 2024, 2023 was marked by the rapidly evolution
                                    of the landscape of UI interactions, driven by advancements in technology and
                                    user expectations. Dive with me in this text to see the main areas changed in
                                    this year.</p>
                            </div>
                        </a>
                    </li>

                    <li class="blog-post-item">
                        <a href="#">
                            <figure class="blog-banner-box">
                                <img src="https://i.postimg.cc/YCCmVkw9/blog-5.jpg"
                                     alt="The forgotten art of spacing" loading="lazy">
                            </figure>

                            <div class="blog-content">
                                <div class="blog-meta">
                                    <p class="blog-category">Design</p>
                                    <span class="dot"></span>
                                    <time datetime="2023-11-12">Nov 12, 2023</time>
                                </div>

                                <h3 class="h3 blog-item-title">The forgotten art of spacing</h3>
                                <p class="blog-text">In the realm of design, spacing is often an overlooked yet
                                    crucial element that can significantly impact the overall aesthetic and
                                    functionality of a composition. This post will emphasize the importance of white
                                    space, margins, and padding in creating visually appealing and effective
                                    designs.</p>
                            </div>
                        </a>
                    </li>

                    <li class="blog-post-item">
                        <a href="#">
                            <figure class="blog-banner-box">
                                <img src="https://i.postimg.cc/zBCBvP16/blog-6.jpg" alt="Design digest #79"
                                     loading="lazy">
                            </figure>

                            <div class="blog-content">
                                <div class="blog-meta">
                                    <p class="blog-category">Design</p>
                                    <span class="dot"></span>
                                    <time datetime="2023-10-20">Oct 20, 2023</time>
                                </div>

                                <h3 class="h3 blog-item-title">Design digest #79</h3>
                                <p class="blog-text">Hi, my friends. In this Design Digest I'll focus in the tools
                                    and resources that we use daily in our projects. Also, I'll include examples of
                                    software recommendations, online courses, and design communities that foster
                                    collaboration and learning.</p>
                            </div>
                        </a>
                    </li>
                </ul>
            </section>
        </article>

        <article class="contact " data-page="فصل ۴">
            <header>
                <h2 class="h2 article-title">Contact</h2>
            </header>

            <section class="mapbox" data-mapbox>
                <figure>
                    <iframe
                            src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d199666.5651251294!2d-121.58334177520186!3d38.56165006739519!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x809ac672b28397f9%3A0x921f6aaa74197fdb!2sSacramento%2C%20CA%2C%20USA!5e0!3m2!1sen!2sbd!4v1647608789441!5m2!1sen!2sbd"
                            width="400" height="300" loading="lazy"></iframe>
                </figure>
            </section>

            <section class="contact-form">
                <h3 class="h3 form-title">Contact Form</h3>

                <form action="#" class="form" data-form>
                    <div class="input-wrapper">
                        <input type="text" name="fullname" class="form-input" placeholder="Full name" required
                               data-form-input>
                        <input type="email" name="email" class="form-input" placeholder="Email Address" required
                               data-form-input>
                    </div>

                    <textarea name="message" class="form-input" placeholder="Your Message" required
                              data-form-input=""></textarea>

                    <button class="form-btn" type="submit" disabled data-form-btn>
                        <ion-icon name="paper-plane"></ion-icon>
                        <span>Send Message</span>
                    </button>
                </form>
            </section>
        </article>
    </div>
</main>

<script src="../assets/js/main.js"></script>

<script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
<script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
</body>

</html>